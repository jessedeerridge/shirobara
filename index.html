
<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>è¡€ã¨åˆƒã®ç™½è–”è–‡</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* â˜… mainèƒŒæ™¯ï¼šå…¥å®¤å‰/å…¥å®¤å¾Œã§åˆ‡æ›¿ */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('sirobaramain.jpg'); }
  main.joined{ background-image:url('sirobaramain.jpg'); }

  /* â˜… ä¸Šéƒ¨ï¼šã‚³ã‚¤ãƒ³æ‰€æœ‰è¡¨ç¤ºï¼ˆå…¬é–‹ï¼ˆtable/reveal2ï¼‰ã¾ã§è¡¨ç¤ºï¼‰ */
  .power-banner{
    position:fixed;
    left:50%;
    top:60px;
    transform:translateX(-50%);
    width:min(300px, calc(100% - 24px));
    background:rgba(20,20,20,.92);
    color:#fff;
    border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:10px 12px;
    z-index:405;
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  .power-banner.hidden{display:none;}
  .power-banner-num{
    width:42px;height:42px;border-radius:12px;
    display:grid;place-items:center;
    border:1px solid rgba(255,255,255,.18);
    font-weight:1000;
    font-size:22px;
    flex:0 0 auto;
    background:rgba(255,255,255,.08);
  }
  .power-banner-body{flex:1 1 auto;min-width:0;}

  .power-banner-text{
    font-weight:900;
    font-size:13px;
    line-height:1.35;
    white-space:pre-wrap;
    word-break:break-word;
  }

  /* â˜… ç€å¸­ãƒãƒƒãƒ— */
  /* â˜… ç€å¸­ãƒãƒƒãƒ— */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:#111;border:1px solid #111;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
    color:#fff;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .seat-pop .btn{
    background:#111;
    color:#fff;
    border-color:#fff;
  }
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'âœ•';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* â˜… ãƒ›ã‚¹ãƒˆäººæ•°é¸æŠä¸­ï¼šå‚åŠ è€…ã«å‡ºã™é»’ãƒãƒƒãƒ—ï¼ˆä¸‹å›ºå®šï¼‰ */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* â˜…ãƒãƒƒãƒ—ç§»å‹•ä¸å¯ãƒãƒƒãƒ—ï¼ˆä¸‹å›ºå®šï¼‰ */
  .coin-warning-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:230;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .coin-warning-pop.hidden{display:none;}

  /* â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††é…ç½®ç”¨ */
  .player-circle{
    position:relative;
    width:320px;height:320px;
    margin:70px auto 0;
    border-radius:50%;
    box-sizing:border-box;
    border:none;
  }

  /* ===== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒ¼ãƒ‰ï¼ˆowncoin + name + owned coinsï¼‰ ===== */
  .player-node{
    position:absolute;
    transform:translate(-50%,-50%);
    width:76px; height:56px;
    display:grid;
    place-items:center;
    user-select:none;
    z-index: 10;

  }
  .owncoin{
    position:absolute;
    width:54px;height:54px;border-radius:50%;
    border:transparent;
    background:transparent;
    box-shadow:transparent;
  }


  .player-tag{
    position:relative;
    padding:4px 10px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:2;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }
  .player-tag.power5-selected{
    outline:2px dashed rgba(220,38,38,.95);
    outline-offset:2px;
  }

  /* æ‰€æœ‰ã‚³ã‚¤ãƒ³è¡¨ç¤ºï¼ˆã‚¿ã‚°å³å´ãƒ»ã‚¿ã‚°å†…ã§ã¯ãªã„ï¼‰ */
  .owned-coins{
    position:absolute;
    left:calc(50% + 34px);
    top:50%;
    transform:translateY(-50%);
    display:flex; gap:4px; align-items:center;
    z-index:2;
    pointer-events:auto;
  }
  .owned-coin-dot{
    width:22px;height:22px;border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    background:linear-gradient(180deg,#fff,#eee);
    box-shadow:0 8px 16px rgba(0,0,0,.22);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    color:#111;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .owned-coin-dot:active{cursor:grabbing;}
  .owned-coin-dot.locked{opacity:.6; cursor:not-allowed; pointer-events:none;}

  /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°ã®ä¸‹ã«æ‰‡çŠ¶ï¼‰ */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:66px;height:34px;pointer-events:none;
  }
  .player-tag .mini-hand-square{
    position:absolute;
    left:calc(50% - 40px);
    top:100%;
    transform:translate(-50%,10px);

    /* â˜…å¤‰æ›´ï¼šç”»åƒãŒè¦‹ãˆã‚‹ã‚ˆã†å°‘ã—å¤§ãã‚ã«ï¼ˆå¿…è¦ãªã‚‰æˆ»ã—ã¦OKï¼‰ */
    width:11px;
    height:14px;

    border-radius:3px;

    /* â˜…å¤‰æ›´ï¼šcys.jpg */
    background-image:url('cys.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    /* ç”»åƒãŒæš—ããªã‚‰ãªã„ã‚ˆã†ã€å…ƒã®é»’å¡—ã‚Šã¯æ¶ˆã™ */
    background-color:transparent;

    box-shadow:0 2px 6px rgba(0,0,0,.25);
    pointer-events:none;

    /* â˜…center-area(5)ã‚ˆã‚Šå‰ */
    z-index: 120;
  }
  .player-tag .mini-hand-square.hidden{display:none;}
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background-image:url('baraura.jpg');
    background-size:cover;
    background-position:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* â˜…è¿½åŠ ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­é¸æŠï¼ˆåŠ¹æœ11/1/12ï¼‰æ™‚ã®å¤§å°ã‚¢ãƒ‹ãƒ¡ */
  .mini-hand.selectable{
    pointer-events:auto;
    cursor:pointer;
    animation: miniHandPulse 0.95s ease-in-out infinite;
    will-change: transform;
  }
  @keyframes miniHandPulse{
    0%   { transform:translate(-50%,3px) scale(1); }
    50%  { transform:translate(-50%,3px) scale(1.10); }
    100% { transform:translate(-50%,3px) scale(1); }
  }
  /* â˜…è¿½åŠ ï¼šã‚¯ãƒªãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šï¼ˆæ™®æ®µã¯ç„¡åŠ¹ã€é¸æŠä¸­ã ã‘æœ‰åŠ¹ï¼‰ */
  .player-tag .mini-hand-hit{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:66px;height:34px;
    pointer-events:none;
    cursor:pointer;
    background:transparent;
    border-radius:8px;
  }
  .player-tag .mini-hand-hit.active{ pointer-events:auto; }

  /* ===== ä¸­å¤®ã‚¨ãƒªã‚¢ï¼ˆdiscardtable / shuffle / tableä¸¦ã¹ï¼‰ ===== */
 .center-area{
    position:absolute;
    inset:0;
    pointer-events:none;
    z-index:15;
  }
  .center-area .stack-card,
  .center-area .table-card,
  .center-area .shuffle-card,
  .center-area .power-card{
    color:transparent;
    text-shadow:none;
  }

  /* â˜… discardtableï¼šä¸­å¤®ã«2x2ã®ç‚¹ç·šå››è§’ï¼ˆå ´ã‚«ãƒ¼ãƒ‰=60x90ã¨åŒã˜ï¼‰ */
  :root{
    --field-w: 60px;
    --field-h: 90px;
    --slot-gap: 10px;
    --stack-step: 7px;
  }
  .discard-table{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:calc(var(--field-w) * 2 + var(--slot-gap));
    height:calc(var(--field-h) * 2 + var(--slot-gap));
    display:grid;
    grid-template-columns:repeat(2, var(--field-w));
    grid-template-rows:repeat(2, var(--field-h));
    gap:var(--slot-gap);
    pointer-events:none;
  }
  .discard-slot{
    position:relative;
    border:2px dashed rgba(120,120,120,.7);
    border-radius:12px;
    background:rgba(255,255,255,.48);
    box-shadow:0 10px 22px rgba(0,0,0,.06);
    overflow:visible;
  }
  .slot-label{
    position:absolute;
    left:8px; top:7px;
    font-size:10px;
    font-weight:1000;
    opacity:.62;
    letter-spacing:.06em;
    user-select:none;
    pointer-events:none;
  }
  .slot-stack{
    position:absolute;
    inset:0;
    pointer-events:none;
  }

  /* discardã«ç©ã¾ã‚Œã‚‹ã‚«ãƒ¼ãƒ‰ï¼ˆå ´ã‚«ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºï¼‰ */
  .stack-card{
    position:absolute;
    left:50%; top:50%;
    width:var(--field-w);
    height:var(--field-h);
    transform:translate(-50%,-50%);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 10px 20px rgba(0,0,0,.16);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:1000;
    text-align:center;
    padding:4px;
    line-height:1.1;
    box-sizing:border-box;
    background-size:cover;
    background-position:center;

  }
  .stack-card.dead{
    box-shadow:0 10px 20px rgba(0,0,0,.16), 0 0 0 3px rgba(185,28,28,.22) inset;
  }
  .stack-card.pass{
    border:none;
    box-shadow:none;
    background:transparent;
    font-size:26px;
    color:#b91c1c;
    font-weight:1000;
  }

  .shuffle-card{
    position:absolute;
    left:50%; top:50%;
    width:52px;height:78px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background-image:url('baraura.jpg');
    background-size:cover;
    background-position:center;    box-shadow:0 12px 24px rgba(0,0,0,.22);
    transform:translate(-50%,-50%);
    opacity:.98;
  }

  /* â˜… å…¬é–‹å¾Œï¼šä¸­å¤®ã«ã‚«ãƒ¼ãƒ‰ã‚’ä¸¦ã¹ã‚‹ï¼ˆtableï¼‰ */
  .table-area{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%) translateY(15px);
    width:min(320px, calc(100% - 40px));
    display:none;
  }
  .table-area.show{display:block;}
  .table-grid{
    display:grid;
    grid-template-columns:repeat(3, var(--field-w));
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .table-card{
    width:var(--field-w);
    height:var(--field-h);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 12px 24px rgba(0,0,0,.20);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:1000;
    text-align:center;
    padding:4px;
    line-height:1.1;
    box-sizing:border-box;
    background-size:cover;
    background-position:center;

  }
  .table-card.pass{
    border:none;
    box-shadow:none;
    background:transparent;
    font-size:30px;
    color:#b91c1c;
  }
.table-card.pass{
  display: none !important;
}
  /* æå‡ºã—ãŸè£é¢ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼â†’ä¸­å¤®æ–¹å‘ã«è¡¨ç¤ºï¼‰ */
  .played-back{
    position:absolute;
    width:22px;height:30px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.25);
    background-image:url('baraura.jpg');
    background-size:cover;
    background-position:center;
    box-shadow:0 8px 18px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .played-back,
  .played-x{
    transition: left 0.45s ease, top 0.45s ease, transform 0.45s ease;
    will-change: left, top, transform;
  }
  /* â˜…æ›´æ–°ï¼šã‚·ãƒ£ãƒƒãƒ•ãƒ«æ™‚ã¯ã‚«ãƒ¼ãƒ‰ã ã‘ã‚¢ãƒ‹ãƒ¡ã€âœ•ã¯æ¶ˆã™ */
  .played-back.shuffling{
    animation: miniShuffle 1s ease-in-out both;
  }
  .played-x.shuffling{
    /* ã‚·ãƒ£ãƒƒãƒ•ãƒ«ä¸­ã¯ãã®å ´ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã—ã¦æ¶ˆãˆã‚‹ã ã‘ */
    opacity:0;
    transform:translate(-50%,-50%);
  }
  @keyframes miniShuffle{
    0%{
      transform:translate(-50%,-50%) rotate(0deg);
    }
    25%{
      transform:translate(calc(-50% + var(--sx1)), calc(-50% + var(--sy1))) rotate(var(--sr1));
    }
    55%{
      transform:translate(calc(-50% + var(--sx2)), calc(-50% + var(--sy2))) rotate(var(--sr2));
    }
    80%{
      transform:translate(calc(-50% + var(--sx3)), calc(-50% + var(--sy3))) rotate(var(--sr3));
    }
    100%{
      transform:translate(-50%,-50%) rotate(0deg);
    }
  }

  .played-back .bk{
    position:absolute; inset:0;
    border-radius:6px;
    background-size:cover;
    background-position:center;
    opacity:.0;
  }

  /* â˜… å‡ºã•ãªã„æå‡ºï¼šâœ•å˜ä½“ */
  .played-x{
    position:absolute;
    width:30px;height:30px;
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:26px;
    line-height:1;
    color:#b91c1c;
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
    text-shadow:0 6px 14px rgba(0,0,0,.12);
  }

  /* â˜…åŠ¹æœ2ï¼šæå‡ºä½ç½®ã§è¡¨ã«ã™ã‚‹ï¼ˆ1.3å€ï¼‰ */
  .played-front{
    position:absolute;
    width:var(--field-w);
    height:var(--field-h);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 14px 30px rgba(0,0,0,.22);
    pointer-events:none;
    background-size:cover;
    background-position:center;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    box-sizing:border-box;
    padding:6px 6px 6px;
  }
  .played-front .t{
    font-size:11px;
    font-weight:1000;
    line-height:1.1;
    color:#111;
    text-shadow:0 1px 0 rgba(255,255,255,.6);
    background:rgba(255,255,255,.72);
    border:1px solid rgba(0,0,0,.12);
    border-radius:999px;
    padding:2px 6px;
  }

  /* ===== è‡ªåˆ†ã®æ‰‹æœ­è¡¨ç¤ºï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼‰ ===== */
  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;
    justify-content:center;
    gap:8px;
    margin-top:6px;
    min-height:120px;
    align-items:flex-start;
  }

  /* æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆ60x90ï¼‰ */
  .role-card{
    width:60px;height:90px;border-radius:10px;border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.16);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .role-card:active{cursor:grabbing;}
  .role-card .face{
    position:absolute; inset:0;
    border-radius:10px;
    background-size:cover;
    background-position:center;
    opacity:1;
  }
  .role-card .label{
    position:relative;
    padding:6px 6px;
    font-size:13px;
    line-height:1.1;
    opacity:0;
  }

  /* =========================
     â˜…è¿½åŠ ï¼šãƒ—ãƒ¬ã‚¤å¯èƒ½ãªæ‰‹æœ­ã‚«ãƒ¼ãƒ‰ã®å¤§å°ã‚¢ãƒ‹ãƒ¡
     ========================= */
  .role-card.playable{
    animation: playablePulse 0.95s ease-in-out infinite;
    will-change: transform;
  }
  @keyframes playablePulse{
    0%   { transform: scale(1); }
    50%  { transform: scale(1.07); }
    100% { transform: scale(1); }
  }
  /* â˜…è¿½åŠ ï¼šãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ã‚¢ãƒ‹ãƒ¡åœæ­¢ */
  .role-card.playable.dragging{
    animation: none !important;
  }

  /* â€œå‡ºã•ãªã„â€ã‚«ãƒ¼ãƒ‰ï¼ˆåŒã‚µã‚¤ã‚ºãƒ»ç‚¹ç·šã‚°ãƒ¬ãƒ¼æ ï¼‰ */
  .pass-card{
    width:60px;height:90px;border-radius:10px;
    border:2px dashed rgba(140,140,140,.9);
    background:rgba(255,255,255,.6);
    box-shadow:0 10px 24px rgba(0,0,0,.10);
    position:relative;
    display:flex;align-items:center;justify-content:center;
    font-weight:900;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
    color:#555;
  }
  .pass-card .label{
    font-size:13px;
    line-height:1.1;
    padding:0 6px;
  }
  .pass-card:active{ transform:translateY(1px); }

  .drag-ghost{
    position:absolute;
    z-index:9999;
    pointer-events:none;
    transform:translate(-50%,-50%);
    opacity:.95;
  }
  /* ===== å°ã•ã„é»’ã‚«ãƒ¼ãƒ‰(1-12) ï¼‹ é»’ãƒãƒƒãƒ— ===== */
  .power-wrapper{
    margin-top:14px;
    display:flex;
    justify-content:center;
  }
  .power-block{
    display:flex;
    gap:10px;
    align-items:flex-start;
  }
  .power-card{
    width:42px;height:60px;border-radius:10px;
    background:#111;color:#fff;
    display:flex;align-items:center;justify-content:center;
    font-weight:1000;
    font-size:22px;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.1);
    flex:0 0 auto;
  }
  .power-pop{
    width:280px;
    height:64px;
    border-radius:14px;
    background:rgba(20,20,20,.92);
    color:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:8px 10px;
    box-sizing:border-box;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:left;
    line-height:1.25;
    font-weight:900;
    overflow:hidden;
  }
  .power-pop span{
    display:block;
    width:100%;
    white-space:pre-wrap;
    word-break:break-word;
    font-size:14px;
  }

  /* â˜…åŠ¹æœ10ï¼šé¸æŠ/ç¢ºèª/å¤‰æ›´ãƒãƒƒãƒ— */
  .power10-owner-pop,
  .power10-target-pop{
    position:fixed;
    left:50%;
    bottom:10px;
    transform:translateX(-50%);
    background:rgba(20,20,20,.92);
    color:#fff;
    padding:12px 16px;
    border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:240;
    display:flex;
    flex-direction:column;
    gap:8px;
    min-width:260px;
    font-weight:900;
  }
  .power10-owner-pop.hidden,
  .power10-target-pop.hidden{display:none;}
  .power10-owner-actions{
    display:flex;
    justify-content:flex-end;
    gap:8px;
  }
  .power10-confirm-pop{
    position:fixed;
    background:rgba(20,20,20,.92);
    color:#fff;
    padding:10px 12px;
    border-radius:12px;
    box-shadow:0 16px 36px rgba(0,0,0,.35);
    z-index:250;
    transform:translate(-50%,-50%);
    display:flex;
    flex-direction:column;
    gap:8px;
    min-width:200px;
    font-weight:900;
  }
  .power10-confirm-pop.hidden{display:none;}
  .power10-confirm-actions{
    display:flex;
    justify-content:flex-end;
    gap:8px;
  }
  .power10-ghost{
    color:#fff;
    border-color:rgba(255,255,255,.6);
  }


  /* â˜… è¿½ã„å‡ºã—ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* â˜… ãƒ›ã‚¹ãƒˆç”¨ è¨­å®šãƒœã‚¿ãƒ³ï¼ˆå³ä¸‹å›ºå®šï¼‰ */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* â˜… è¨­å®šãƒãƒƒãƒ—ï¼ˆãƒ›ã‚¹ãƒˆå°‚ç”¨ãƒ‘ãƒãƒ«ï¼‰ */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
  }

  /* å·¦ä¸‹ã€Œï¼Ÿã€ */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(70vh, 680px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:900;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
 .help-section{margin-bottom:16px;}
  .help-section:last-child{margin-bottom:0;}
  .help-section-title{font-weight:900;font-size:13px;margin-bottom:6px;}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
    border-bottom:1px dashed #eee;
  }
  .role-row:last-child{border-bottom:none;}
  .role-card-stack{display:flex;gap:6px;align-items:flex-start;}
  .role-card-mini{
    position:relative;
    width:54px;height:76px;border-radius:10px;border:1px solid #ddd;background:#111;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    background-size:cover;
    background-position:center;
  }
  .role-card-mini.dim{opacity:.35;}
  .role-card-mini .count-badge{
    position:absolute;top:4px;right:4px;
    padding:2px 6px;border-radius:999px;
    background:rgba(0,0,0,.75);color:#fff;
    font-size:11px;font-weight:900;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
 .help-effect-grid{display:grid;grid-template-columns:repeat(3, minmax(0, 1fr));gap:8px;}
  .help-effect-card{
    border:1px solid #111;border-radius:12px;
    padding:8px;background:#111;box-shadow:0 4px 10px rgba(0,0,0,.04);
    display:flex;flex-direction:column;gap:4px;
  }
  .help-effect-num{font-weight:900;font-size:14px;color:#fff;}
  .help-effect-text{font-size:12px;line-height:1.4;white-space:pre-wrap;color:#fff;}

  /* ===== ãƒ©ã‚¦ãƒ³ãƒ‰æå‡ºè¡¨ ===== */
  .round-play-wrapper{
    margin:0 auto 16px;
    padding:0 12px;
    max-width:680px;
  }
  .round-play-title{
    font-weight:900;
    font-size:13px;
    text-align:center;
    margin-bottom:8px;
  }
  .round-play-table{
    width:100%;
    border-collapse:collapse;
    background:rgba(255,255,255,.86);
    border-radius:12px;
    overflow:hidden;
  }
  .round-play-table th,
  .round-play-table td{
    border:1px solid #e5e5e5;
    padding:6px;
    text-align:center;
    font-size:12px;
  }
  .round-play-name{
    font-weight:800;
    white-space:nowrap;
  }
  .round-play-cell{
    width:28px;
    height:38px;
  }
  .round-play-card-back{
    width:16px;
    height:23px;
    margin:0 auto;
    border-radius:4px;
    background-size:cover;
    background-position:center;
    box-shadow:0 6px 12px rgba(0,0,0,.18);
  }
  .round-play-pass{
    font-size:22px;
    font-weight:900;
    color:#b91c1c;
    line-height:1;
  }
  /* ===== ã‚³ã‚¤ãƒ³ãƒ—ãƒ¼ãƒ«ï¼ˆå³ä¸Šï¼‰ ===== */
  /* ===== ã‚³ã‚¤ãƒ³ãƒ—ãƒ¼ãƒ«ï¼ˆå³ä¸Šãƒ»ã‚²ãƒ¼ãƒ ç”»é¢ã¨åŒã˜ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼‰ ===== */
  .coin-pool{
    /* main å†…ã®ãƒ­ãƒ“ãƒ¼(#lobby)ã‚’åŸºæº–ã«å›ºå®š */
    position:absolute;
    top:16px;
    right:16px;

    /* center-area ã¨åŒã˜å¹³é¢æ„Ÿï¼ˆå¼·ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã«ã—ãªã„ï¼‰ */
    z-index:6;

   background:transparent;
    border:none;
    border-radius:12px;

    /* æµ®ã„ã¦è¦‹ãˆãªã„ã‚ˆã†ã«å½±ã‚’å¼±ã or ãªã— */
    box-shadow:none;

    padding:0px;
    width:200px;
    display:flex;
    flex-direction:column;
    gap:0px;
  }
  .coin-pool.hidden{display:none;}
  .coin-pool.hidden{display:none;}
  .coin-pool-inner{
    position:relative;
    width:100%;
    aspect-ratio:1 / 1;
    border-radius:12px;
    border:none;
    background:transparent;
    overflow:hidden;
  }

  /* â˜…ãƒ—ãƒ¼ãƒ«å†…ã®å®Ÿä½“ã‚³ã‚¤ãƒ³ */
.coin{
    position:absolute;
    width:22px;height:22px;border-radius:50%;
    /* æ¨¡æ§˜ã‚’æ¶ˆã—ã¦ç”»åƒã«å¤‰æ›´ */
    background-image:url('baracoin.jpg');
    background-size:cover;
    background-position:center;
    border:1px solid rgba(0,0,0,.35);
    box-shadow:0 8px 16px rgba(0,0,0,.22);
    display:grid; place-items:center;
    font-weight:1000;
    font-size:12px;
    cursor:grab;
    user-select:none;
    touch-action:none;
    z-index:2;
    /* ãƒ†ã‚­ã‚¹ãƒˆã‚’éè¡¨ç¤º */
    color:transparent;
}

.coin:before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:50%;
    background:transparent;
}

.owned-coin-dot{
    width:22px;height:22px;border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    /* æ¨¡æ§˜ã‚’æ¶ˆã—ã¦ç”»åƒã«å¤‰æ›´ */
    background-image:url('baracoin.jpg');
    background-size:cover;
    background-position:center;
    box-shadow:0 8px 16px rgba(0,0,0,.22);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    color:#111;
    cursor:grab;
    user-select:none;
    touch-action:none;
    /* ãƒ†ã‚­ã‚¹ãƒˆã‚’éè¡¨ç¤º */
    color:transparent;
}
.owned-coin-dot:before{
    content:'';
    position:absolute;
    inset:0;
    border-radius:50%;
    background:transparent;
}

  .coin:active{cursor:grabbing;}
  .coin.locked{opacity:.6; cursor:not-allowed; pointer-events:none;}

  /* â˜… ãƒ›ã‚¹ãƒˆï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ï¼ˆå³ä¸‹ãƒ»é»’ã„å››è§’ãƒãƒƒãƒ—ï¼‰ */
  .next-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:74px;
    height:74px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(20,20,20,.92);
    color:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    font-weight:1000;
    line-height:1.1;
    cursor:pointer;
    z-index:275;
    display:none;
  }
  .next-round-btn.visible{display:block;}

  /* â˜…æå‡ºãƒãƒ¼ã‚«ãƒ¼ã‚’ center-area ã‚ˆã‚Šä¸Šã¸ */
  .played-back,
  .played-x,
  .played-front{
    z-index: 50;
  }

  /* â˜…åŠ¹æœ7ï¼šéœŠé­‚ã‚«ãƒ¼ãƒ‰ï¼ˆã‚³ã‚¤ãƒ³ownãŒ7ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ä¸­å¤®ã«å‡ºã‚‹ï¼‰ */
  .spirit-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:520;
    pointer-events:none;
  }
  .spirit-overlay.hidden{display:none;}
  .spirit-card{
    width:60px;
    height:90px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.30);
    background-size:cover;
    background-position:center;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1000;
    cursor:grab;
    user-select:none;
    touch-action:none;
    pointer-events:auto;
  }
  .spirit-card:active{cursor:grabbing;}

  /* =========================
     â˜…æ›´æ–°ï¼šåŠ¹æœ3/4ã®ã€Œè‡ªåˆ†ã®æ‰‹æœ­ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã€æ¼”å‡º
     ========================= */
  .my-hand.power34-hidden .role-card,
  .my-hand.power34-hidden .pass-card{
    opacity:0;
    pointer-events:none;
  }
  .power34-shuffle-overlay{
    position:fixed;
    inset:0;
    display:none;
    z-index:560;
    pointer-events:none;
  }
  .power34-shuffle-overlay.show{display:block;}
  .power34-shuffle-card{
    position:absolute;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.22);
    background-size:cover;
    background-position:center;
    box-shadow:0 12px 24px rgba(0,0,0,.25);
    transform:translate(0,0) rotate(0deg);
    transition:transform 0.55s ease;
    will-change:transform;
  }
  .power34-shuffle-overlay.stacked .power34-shuffle-card{
    transform:translate(var(--tx), var(--ty)) rotate(var(--rot));
  }

  /* =========================
     â˜…è¿½åŠ ï¼šåŠ¹æœ11ã®ã€Œè¦—ãè¦‹ã€è¡¨ç¤ºï¼ˆè‡ªåˆ†ã ã‘ï¼‰
     ========================= */
  .peek-overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.18);
    z-index:610;
    pointer-events:none;
  }
  .peek-overlay.hidden{display:none;}
  .peek-card{
    width:96px;
    height:144px;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 18px 44px rgba(0,0,0,.32);
    background-size:cover;
    background-position:center;
    position:relative;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    box-sizing:border-box;
    padding:8px;
  }
 .peek-label{
    font-size:12px;
    font-weight:1000;
    color:#111;
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.12);
    border-radius:999px;
    padding:2px 8px;
    text-shadow:0 1px 0 rgba(255,255,255,.6);
    display:none;
  }

  /* =========================
     â˜…è¿½åŠ ï¼šåŠ¹æœ11ã®ç‚¹ç·šçŸ¢å°ï¼‹ğŸ‘ï¼ˆå…¨å“¡è¡¨ç¤ºï¼‰
     ========================= */
  .arrow-layer{
    position:fixed;
    inset:0;
    z-index:590;
    pointer-events:none;
  }
  .arrow-layer.hidden{display:none;}

  /* â˜…åŠ¹æœ5ï¼šé¸ã°ã‚ŒãŸ2äººã‚’èµ¤ç‚¹ç·šã§çµã¶ */
  .power5-link-layer{
    position:fixed;
    inset:0;
    z-index:588;
    pointer-events:none;
  }
  .power5-link-layer.hidden{display:none;}

/* â˜…è¿½åŠ ï¼šãƒãƒ¼ãƒ ã‚¿ã‚°å·¦å¤–ã®ğŸ¤šğŸ»ãƒãƒ¼ã‚¯ */
.player-tag .handmark{
  position:absolute;
  right:100%;              /* ã‚¿ã‚°ã®å¤–ï¼ˆå·¦å´ï¼‰ã¸ */
  margin-right:6px;
  top:50%;
  transform:translateY(-50%);
  font-size:16px;
  line-height:1;
  pointer-events:none;     /* ã‚¯ãƒªãƒƒã‚¯é‚ªé­”ã—ãªã„ */
  filter: drop-shadow(0 2px 4px rgba(0,0,0,.25));
}

/* =========================
   â˜…è¿½åŠ ï¼šå…¬é–‹æ™‚ã€Œç™½è–”è–‡ï¼‹åˆƒã€æ¼”å‡º
   ========================= */
.roseblade-overlay{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.08);
  z-index:720;
  pointer-events:none;
}
.roseblade-overlay.hidden{ display:none; }

.rb-stage{
  position:relative;
  width:220px; height:300px;   /* â†å¤§ãã */
  transform:translateZ(0);
}

.rb-rose, .rb-blade{
  position:absolute;
  left:50%; top:50%;
  width:140px; height:210px;   /* â†å¤§ãã */
  border-radius:18px;
  border:1px solid rgba(0,0,0,.22);
  background:#fff;
  background-size:cover;
  background-position:center;
  box-shadow:0 22px 60px rgba(0,0,0,.30);
  transform:translate(-50%,-50%);
  opacity:0;
}


.rb-rose{ z-index:2; }
.rb-blade{ z-index:1; }

.rb-pieces{
  position:absolute; inset:0;
  z-index:3;
  pointer-events:none;
}

.rb-piece{
  position:absolute;
  left:50%; top:50%;
  width:28px; height:42px;
  border-radius:8px;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  background-size:cover;
  background-position:center;
  box-shadow:0 14px 30px rgba(0,0,0,.18);
  transform:translate(-50%,-50%) rotate(0deg);
  opacity:0;
}

/* å†ç”Ÿãƒˆãƒªã‚¬ */
.roseblade-overlay.play .rb-rose{
  animation: rbRoseIn .22s ease-out both, rbRoseScatter .62s ease-in .22s both;
}
.roseblade-overlay.play .rb-blade{
  animation: rbBladeIn .22s ease-out .44s both, rbBladeShake .38s ease-in-out .66s both;
}
.roseblade-overlay.play .rb-piece{
  animation: rbPiecePop .10s ease-out .22s both, rbPieceFly .70s ease-out .24s both;
}

@keyframes rbRoseIn{
  from{ opacity:0; transform:translate(-50%,-50%) translateY(14px) scale(.98); }
  to  { opacity:1; transform:translate(-50%,-50%) translateY(0) scale(1); }
}
@keyframes rbRoseScatter{
  0%  { opacity:1; transform:translate(-50%,-50%) scale(1); filter:none; }
  100%{ opacity:0; transform:translate(-50%,-50%) scale(.92); filter:blur(.4px); }
}
@keyframes rbBladeIn{
  from{ opacity:0; transform:translate(-50%,-50%) scale(.92); }
  to  { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
@keyframes rbBladeShake{
  0%  { transform:translate(-50%,-50%) rotate(0deg); }
  20% { transform:translate(calc(-50% - 1px),-50%) rotate(-3deg); }
  45% { transform:translate(calc(-50% + 2px),-50%) rotate(3deg); }
  70% { transform:translate(calc(-50% - 1px),-50%) rotate(-2deg); }
  100%{ transform:translate(-50%,-50%) rotate(0deg); }
}
@keyframes rbPiecePop{
  from{ opacity:0; transform:translate(-50%,-50%) scale(.9); }
  to  { opacity:1; transform:translate(-50%,-50%) scale(1); }
}
@keyframes rbPieceFly{
  from{ transform:translate(-50%,-50%) rotate(0deg); opacity:1; }
  to{
    transform:translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) rotate(var(--rot));
    opacity:0;
  }
}

.slot-target-badge{
  position:absolute;
  right:-6px;
  top:-6px;

  width:22px;
  height:22px;
  border-radius:999px;

  /* â˜…ç´°ã„æ ï¼ˆä¸»å¼µã—ã™ããªã„ï¼‰ */
  border:1px solid rgba(17,17,17,.25);

  /* â˜…é€ã‘ã¦è¦‹ãˆã‚‹èƒŒæ™¯ï¼ˆã¼ã‹ã—ç„¡ã—ï¼‰ */
  background:rgba(255,255,255,.08);
  color:rgba(17,17,17,.82);

  backdrop-filter:none;

  display:grid;
  place-items:center;
  font-weight:1000;
  font-size:12px;

  /* â˜…å½±ã¯æœ€å°é™ */
  box-shadow:0 1px 4px rgba(0,0,0,.10);

  pointer-events:none;
  user-select:none;
  z-index:120;
}

/* =========================
   â˜…æ›´æ–°ï¼šç”Ÿå­˜ã‚¯ãƒªã‚¢æ¼”å‡ºï¼ˆç™½è–”è–‡æ‹¡å¤§ï¼‹ã¡ã‚‡ã„æºã‚Œâ†’3ç§’å¾Œã«æ¶ˆãˆã‚‹ï¼‰
   ========================= */
.aliveclear-overlay{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.10);
  z-index:740;
  pointer-events:none;
}
.aliveclear-overlay.hidden{display:none;}

.aliveclear-card{
  width:170px; height:255px;
  border-radius:18px;
  border:1px solid rgba(0,0,0,.22);
  background:#fff;
  background-size:cover;
  background-position:center;
  box-shadow:0 26px 70px rgba(0,0,0,.34);
  transform:scale(.92);
  opacity:0;
  will-change: transform, opacity;
}

.aliveclear-overlay.play .aliveclear-card{
  /* 3ç§’ã§å®Œçµï¼ˆæ‹¡å¤§â†’æºã‚Œâ†’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆï¼‰ */
  animation: aliveClearShow 3.0s ease-out both;
}

@keyframes aliveClearShow{
  0%   { opacity:0; transform:scale(.88) rotate(0deg); }
  10%  { opacity:1; transform:scale(1.06) rotate(0deg); }

  /* ã¡ã‚‡ã„æºã‚Œï¼ˆæ‹¡å¤§å¾Œã«å°åˆ»ã¿ï¼‰ */
  18%  { transform:scale(1.06) rotate(-2.2deg); }
  26%  { transform:scale(1.06) rotate( 2.2deg); }
  34%  { transform:scale(1.06) rotate(-1.6deg); }
  42%  { transform:scale(1.06) rotate( 1.6deg); }
  50%  { transform:scale(1.06) rotate(-1.1deg); }
  58%  { transform:scale(1.06) rotate( 1.1deg); }
  66%  { transform:scale(1.06) rotate(-0.7deg); }
  74%  { transform:scale(1.06) rotate( 0.7deg); }
  82%  { transform:scale(1.06) rotate(0deg); }

  /* çµ‚ç›¤ã§æ¶ˆã™ */
  92%  { opacity:1; transform:scale(1.06) rotate(0deg); }
  100% { opacity:0; transform:scale(1.02) rotate(0deg); }
}


/* =========================
   â˜…è¿½åŠ ï¼šã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºï¼ˆç™½è–”è–‡æ•£ã‚Šï¼‹èƒŒé¢ã‹ã‚‰æš—åˆƒï¼‰
   ========================= */
.gameover-overlay{
  position:fixed; inset:0;
  display:flex; align-items:center; justify-content:center;
  background:rgba(0,0,0,.10);
  z-index:760;
  pointer-events:none;
}
.gameover-overlay.hidden{display:none;}



</style>
</head>

<body>
<header>
  <h1>è¡€ã¨åˆƒã®ç™½è–”è–‡</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<!-- â˜… ã‚³ã‚¤ãƒ³æ‰€æœ‰ï¼šæ•°å­—ï¼†åŠ¹æœï¼ˆå…¬é–‹ï¼ˆtable/reveal2ï¼‰ã¾ã§è¡¨ç¤ºï¼‰ -->
<div id="powerBanner" class="power-banner hidden" aria-live="polite">
  <div id="powerBannerNum" class="power-banner-num">?</div>
  <div class="power-banner-body">
    <div id="powerBannerText" class="power-banner-text"></div>
  </div>
</div>

<!-- â˜… åŠ¹æœ7ï¼šéœŠé­‚ã‚«ãƒ¼ãƒ‰ï¼ˆã‚³ã‚¤ãƒ³ownãŒ7ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ï¼‰ -->
<div id="spiritOverlay" class="spirit-overlay hidden" aria-label="éœŠé­‚ä»˜ä¸">
  <div id="spiritCard" class="spirit-card" title="éœŠé­‚ã‚«ãƒ¼ãƒ‰">éœŠé­‚</div>
</div>

<!-- â˜…è¿½åŠ ï¼šåŠ¹æœ11 è¦—ãè¦‹ï¼ˆè‡ªåˆ†ã ã‘ï¼‰ -->
<div id="peekOverlay" class="peek-overlay hidden" aria-hidden="true">
  <div id="peekCard" class="peek-card">
    <div id="peekLabel" class="peek-label">â€”</div>
  </div>
</div>

<!-- â˜…è¿½åŠ ï¼šå…¬é–‹æ™‚ã€Œç™½è–”è–‡ï¼‹åˆƒã€æ¼”å‡ºï¼ˆå…¨å“¡ï¼‰ -->
<div id="roseBladeOverlay" class="roseblade-overlay hidden" aria-hidden="true">
  <div class="rb-stage">
    <div id="rbBlade" class="rb-blade" aria-hidden="true"></div>
    <div id="rbRose" class="rb-rose" aria-hidden="true"></div>
    <div id="rbPieces" class="rb-pieces" aria-hidden="true"></div>
  </div>
</div>


<!-- â˜…è¿½åŠ ï¼šå…¬é–‹æ™‚ã€Œç™½è–”è–‡ï¼‹åˆƒã€æ¼”å‡ºï¼ˆå…¨å“¡ï¼‰ -->
<div id="roseBladeOverlay" class="roseblade-overlay hidden" aria-hidden="true">
  <div class="rb-stage">
    <div id="rbBlade" class="rb-blade" aria-hidden="true"></div>
    <div id="rbRose" class="rb-rose" aria-hidden="true"></div>
    <div id="rbPieces" class="rb-pieces" aria-hidden="true"></div>
  </div>
</div>

<!-- â˜…è¿½åŠ ï¼šç”Ÿå­˜ã‚¯ãƒªã‚¢ï¼ˆç™½è–”è–‡æ‹¡å¤§3ç§’ï¼‰ -->
<div id="aliveClearOverlay" class="aliveclear-overlay hidden" aria-hidden="true">
  <div id="aliveClearCard" class="aliveclear-card" aria-hidden="true"></div>
</div>

<!-- â˜…è¿½åŠ ï¼šã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆç™½è–”è–‡æ•£ã‚Šï¼‹èƒŒé¢ã‹ã‚‰æš—åˆƒï¼‰ -->
<div id="gameOverOverlay" class="gameover-overlay roseblade-overlay hidden" aria-hidden="true">
  <div class="rb-stage">
    <div id="goBlade" class="rb-blade" aria-hidden="true"></div>
    <div id="goRose" class="rb-rose" aria-hidden="true"></div>
    <div id="goPieces" class="rb-pieces" aria-hidden="true"></div>
  </div>
</div>



<!-- â˜…è¿½åŠ ï¼šåŠ¹æœ5 èµ¤ç‚¹ç·šãƒªãƒ³ã‚¯ï¼ˆå…¨å“¡ï¼‰ -->
<div id="power5LinkLayer" class="power5-link-layer hidden" aria-hidden="true">
  <svg id="power5LinkSvg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
    <line id="power5LinkLine" x1="0" y1="0" x2="0" y2="0"
      stroke="rgba(220,38,38,.95)"
      stroke-width="3"
      stroke-dasharray="6 6" />
    <text id="power5LinkBow" x="0" y="0"
      font-size="20"
      text-anchor="middle"
      dominant-baseline="middle">ğŸ€</text>
  </svg>
</div>

<!-- â˜…è¿½åŠ ï¼šåŠ¹æœ11 ç‚¹ç·šçŸ¢å°ï¼‹ğŸ‘ï¼ˆå…¨å“¡ï¼‰ -->
<div id="arrowLayer" class="arrow-layer hidden" aria-hidden="true">
  <svg id="arrowSvg" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">

    <defs>
      <marker id="arrowHead" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
        <path d="M0,0 L9,3 L0,6 Z" fill="rgba(20,20,20,.92)"></path>
      </marker>
    </defs>
    <line id="arrowLine" x1="0" y1="0" x2="0" y2="0"
      stroke="rgba(20,20,20,.92)"
      stroke-width="3"
      stroke-dasharray="8 7"
      marker-end="url(#arrowHead)" />
    <text id="arrowEye" x="0" y="0"
      font-size="22"
      text-anchor="middle"
      dominant-baseline="middle">ğŸ‘</text>
  </svg>
</div>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="åå‰ï¼ˆ4æ–‡å­—ä»¥å†…ï¼‰" maxlength="4" />
    <input id="roomCode" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆæœªå…¥åŠ›ã§è‡ªå‹•ç”Ÿæˆï¼‰" maxlength="12" />
    <button class="btn primary" id="btnJoin">å…¥å®¤</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ãƒ­ãƒ“ãƒ¼</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ã“ã“ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

    <div id="playerCircle" class="player-circle">
      <!-- ä¸­å¤®ã‚¨ãƒªã‚¢ -->
      <div id="centerArea" class="center-area">
        <!-- â˜… discardtableï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰ -->
        <div id="discardTable" class="discard-table" aria-label="discardtable">
          <!-- å·¦ä¸Šï¼šç™½è–”è–‡ -->
          <div class="discard-slot" data-slot="rose">
            <div class="slot-label">ç™½è–”è–‡</div>
            <div class="slot-stack" id="slotRose"></div>
          </div>
          <!-- å³ä¸Šï¼šåˆƒ -->
          <div class="discard-slot" data-slot="blade">
            <div class="slot-label">åˆƒ</div>
            <div class="slot-stack" id="slotBlade"></div>
          </div>
          <!-- å·¦ä¸‹ï¼šç”Ÿå­˜ï¼ˆä¿¡è€…/å¸æ•™ï¼‰ -->
          <div class="discard-slot" data-slot="alive">
            <div class="slot-label">ç”Ÿå­˜</div>
            <div id="aliveTargetBadge" class="slot-target-badge">?</div>
            <div class="slot-stack" id="slotAlive"></div>
          </div>
          <!-- å³ä¸‹ï¼šæ­»äº¡ï¼ˆä¿¡è€…/å¸æ•™ï¼‰ -->
          <div class="discard-slot" data-slot="dead">
            <div class="slot-label">æ­»äº¡</div>
            <div id="deadTargetBadge" class="slot-target-badge">?</div>
            <div class="slot-stack" id="slotDead"></div>
          </div>
        </div>

        <div id="tableArea" class="table-area" aria-label="table cards">
          <div class="table-grid" id="tableGrid"></div>
        </div>
      </div>
    </div>

<div id="coinPool" class="coin-pool hidden">
  <div id="coinPoolInner" class="coin-pool-inner"></div>
</div>
    <div class="my-hand-wrapper">
      <div class="my-hand-title">è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰</div>
      <div id="myHand" class="my-hand"></div>

      <div class="power-wrapper" id="powerWrapper" style="display:none;">
        <div class="power-block">
          <div id="powerCard" class="power-card">?</div>
          <div class="power-pop"><span id="powerText"></span></div>
        </div>
      </div>
   </div>
  </div>
</main>

<!-- â˜…åŠ¹æœ10ï¼šé¸æŠ/ç¢ºèª/å¤‰æ›´ãƒãƒƒãƒ— -->
<div id="power10OwnerPop" class="power10-owner-pop hidden">
  <div>ã‚«ãƒ¼ãƒ‰ã‚’å¤‰ãˆã•ã›ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸ã¹ã¾ã™ã€‚</div>
  <div class="power10-owner-actions">
    <button class="btn ghost power10-ghost" id="btnPower10Skip">é¸ã°ãªã„</button>
  </div>
</div>

<div id="power10TargetPop" class="power10-target-pop hidden">
  ã‚«ãƒ¼ãƒ‰ã‚’å¤‰ãˆã¦ãã ã•ã„ã€‚
</div>

<div id="power10ConfirmPop" class="power10-confirm-pop hidden">
  <div class="power10-confirm-text">ã€Œ<span id="power10ConfirmName">â€”</span>ã€ã«ã‚«ãƒ¼ãƒ‰ã‚’å¤‰ãˆã•ã›ã¾ã™ã‹ï¼Ÿ</div>
  <div class="power10-confirm-actions">
    <button class="btn ghost power10-ghost" id="btnPower10ConfirmNo">ã„ã„ãˆ</button>
    <button class="btn primary" id="btnPower10ConfirmYes">ã¯ã„</button>
  </div>
</div>

<div id="power10SkipDialog" class="dialog-backdrop hidden">
  <div class="dialog-box">
    <p>é¸ã°ãªãã¦ã„ã„ã§ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnPower10SkipNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnPower10SkipYes">ã¯ã„</button>
    </div>
  </div>
</div>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’é¸æŠä¸­</div>
<div id="coinWarningPop" class="coin-warning-pop hidden">ã‚‚ã†æ°´æ™¶ãƒãƒƒãƒ—ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</div>

<div id="seatPop" class="seat-pop hidden">

  <div class="row"><label>å¸­ã‚’é¸æŠ</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">è¦³æˆ¦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„å‡ºã—ã¦ã€ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnKickYes">ã¯ã„</button>
    </div>
  </div>
</div>

<!-- â˜… åŠ¹æœ7ï¼šæˆã‘ã¾ã™ã‹ï¼ˆã¯ã„/ã„ã„ãˆï¼‰ -->
<div id="giveDialog" class="dialog-backdrop hidden">
  <div class="dialog-box">
    <p id="giveMessage">ã€Œâ€¦ã€ã«æˆã‘ã¾ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnGiveNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnGiveYes">ã¯ã„</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="è¨­å®š">âš™</button>
<button id="helpBtn" class="help-btn" title="ã‚«ãƒ¼ãƒ‰åŠ¹æœä¸€è¦§">ï¼Ÿ</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="ã‚«ãƒ¼ãƒ‰åŠ¹æœä¸€è¦§">
    <div class="help-pop-header">
      <div class="help-pop-title">ã‚«ãƒ¼ãƒ‰ä¸€è¦§</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ãƒ›ã‚¹ãƒˆè¨­å®š</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
  </div>
  <div class="start-pop-main">
    ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã§å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒã€‚<br>
    ã€Œãƒªã‚»ãƒƒãƒˆã€ã§äººæ•°é¸æŠã¸æˆ»ã—ã¾ã™ï¼ˆå†…å®¹ã¯å¾Œã§ï¼‰ã€‚<br>
    <span style="opacity:.75;">â€» ã‚¹ã‚¿ãƒ¼ãƒˆå¾Œï¼šæå‡º & ã‚³ã‚¤ãƒ³ãƒ—ãƒ¼ãƒ«ãŒæœ‰åŠ¹</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="btnGameStart" class="btn primary">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
</div>


<!-- â˜…æ›´æ–°ï¼šåŠ¹æœ3/4ã®æ‰‹æœ­ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¼”å‡ºï¼ˆè‡ªåˆ†ã ã‘ï¼‰ -->
<div id="power34ShuffleOverlay" class="power34-shuffle-overlay" aria-hidden="true"></div>

<!-- â˜…ãƒ›ã‚¹ãƒˆï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ -->
<button id="btnNextRound" class="next-round-btn" title="æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰">æ¬¡<br>ãƒ©ã‚¦ãƒ³ãƒ‰</button>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

// â–¼ Firebase è¨­å®š
const firebaseConfig = {
  apiKey: "AIzaSyDUP1foVQnitM45do_UtYLkcc9gvgQC-xw",
  authDomain: "timebomb-3b0c7.firebaseapp.com",
  databaseURL: "https://timebomb-3b0c7-default-rtdb.firebaseio.com",
  projectId: "timebomb-3b0c7",
  storageBucket: "timebomb-3b0c7.firebasestorage.app",
  messagingSenderId: "532935786630",
  appId: "1:532935786630:web:ef1f97c862bfaad67d1107",
  measurementId: "G-K8NRR8K64Y"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

// â–¼ çŠ¶æ…‹
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,

  room: {},
  hands: {},
  game: {},
  plays: {},
  roundPlays: {},
  discard: {},

  coins: {},
  players: [],
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const coinWarningPop = document.getElementById('coinWarningPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const giveDialog = document.getElementById('giveDialog');
const giveMessage = document.getElementById('giveMessage');
const btnGiveYes = document.getElementById('btnGiveYes');
const btnGiveNo = document.getElementById('btnGiveNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');

function clientToMainCoords(clientX, clientY){
  const rect = mainEl.getBoundingClientRect();
  return {
    x: clientX - rect.left + mainEl.scrollLeft,
    y: clientY - rect.top + mainEl.scrollTop
  };
}
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const powerWrapper = document.getElementById('powerWrapper');
const powerCardEl = document.getElementById('powerCard');
const powerTextEl = document.getElementById('powerText');

const power10OwnerPop = document.getElementById('power10OwnerPop');
const power10TargetPop = document.getElementById('power10TargetPop');
const power10ConfirmPop = document.getElementById('power10ConfirmPop');
const power10ConfirmName = document.getElementById('power10ConfirmName');
const btnPower10Skip = document.getElementById('btnPower10Skip');
const btnPower10ConfirmNo = document.getElementById('btnPower10ConfirmNo');
const btnPower10ConfirmYes = document.getElementById('btnPower10ConfirmYes');
const power10SkipDialog = document.getElementById('power10SkipDialog');
const btnPower10SkipNo = document.getElementById('btnPower10SkipNo');
const btnPower10SkipYes = document.getElementById('btnPower10SkipYes');

const powerBanner = document.getElementById('powerBanner');
const powerBannerNum = document.getElementById('powerBannerNum');
const powerBannerText = document.getElementById('powerBannerText');

const spiritOverlay = document.getElementById('spiritOverlay');
const spiritCard = document.getElementById('spiritCard');

const coinPool = document.getElementById('coinPool');
const coinPoolInner = document.getElementById('coinPoolInner');
let roundPlayWrapper = null;
let roundPlayTable = null;

const discardTable = document.getElementById('discardTable');
const slotRose  = document.getElementById('slotRose');
const slotBlade = document.getElementById('slotBlade');
const slotAlive = document.getElementById('slotAlive');
const slotDead  = document.getElementById('slotDead');

const aliveTargetBadge = document.getElementById('aliveTargetBadge');
const deadTargetBadge  = document.getElementById('deadTargetBadge');

/* â˜…è¿½åŠ ï¼šç”Ÿå­˜ã‚¯ãƒªã‚¢/ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡º */
const aliveClearOverlay = document.getElementById('aliveClearOverlay');
const aliveClearCard = document.getElementById('aliveClearCard');

const gameOverOverlay = document.getElementById('gameOverOverlay');
const goRose = document.getElementById('goRose');
const goBlade = document.getElementById('goBlade');
const goPieces = document.getElementById('goPieces');


const tableArea = document.getElementById('tableArea');
const tableGrid = document.getElementById('tableGrid');

const btnNextRound = document.getElementById('btnNextRound');
const power34ShuffleOverlay = document.getElementById('power34ShuffleOverlay');

/* â˜…è¿½åŠ ï¼šåŠ¹æœ11ã®è¦—ãè¦‹UI + çŸ¢å°UI */
const peekOverlay = document.getElementById('peekOverlay');
const peekCard = document.getElementById('peekCard');
const peekLabel = document.getElementById('peekLabel');
const power5LinkLayer = document.getElementById('power5LinkLayer');
const power5LinkSvg = document.getElementById('power5LinkSvg');
const power5LinkLine = document.getElementById('power5LinkLine');
const power5LinkBow = document.getElementById('power5LinkBow');
const arrowLayer = document.getElementById('arrowLayer');
const arrowSvg = document.getElementById('arrowSvg');
const arrowLine = document.getElementById('arrowLine');
const arrowEye = document.getElementById('arrowEye');

/* â˜…è¿½åŠ ï¼šå…¬é–‹æ™‚ã€Œç™½è–”è–‡ï¼‹åˆƒã€æ¼”å‡º */
const roseBladeOverlay = document.getElementById('roseBladeOverlay');
const rbRose = document.getElementById('rbRose');
const rbBlade = document.getElementById('rbBlade');
const rbPieces = document.getElementById('rbPieces');


/* =========================
   1ã€œ12ã®åŠ¹æœ
   ========================= */
const POWER_TEXT = {
  1: "ã‚«ãƒ¼ãƒ‰ã‚’æŒã£ã¦ã„ã‚‹äººã‚’æŒ‡åã™ã‚‹ã€‚\nãã®äººã«å¼·åˆ¶çš„ã«ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã•ã›ã‚‹ã€‚",
  2: "ã“ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã«å‡ºã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ã¯ã€\nãƒ©ã‚¦ãƒ³ãƒ‰ã®æœ€å¾Œã«èª°ãŒä½•ã‚’å‡ºã—ãŸã‹ã‚ã‹ã‚‹ã€‚",
  3: "å³éš£ã‚Šã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ãªã‚‰ã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã€‚",
  4: "å·¦éš£ã‚Šã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹ãªã‚‰ã€ãƒ©ãƒ³ãƒ€ãƒ ã§ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã€‚",
  5: "æŒ‡åã—ãŸäºŒäººã¯å¿…ãšåŒã˜è¡Œå‹•ã‚’è¡Œã†ã€‚\nï¼ˆå¾Œã®äººãŒå…ˆã®äººã‚’ã¾ã­ã‚‹ã€‚ï¼‰",
  6: "å…¨å“¡ãŒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—çµ‚ã‚ã£ãŸå¾Œã«ã€\nè‡ªåˆ†ãŒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã‹ã©ã†ã‹æ±ºã‚ã‚‰ã‚Œã‚‹ã€‚",
  7: "ã‚ãªãŸãŒæŒ‡åã—ãŸäººã¯å¹½é­‚ä¸€æšã‚’å¾—ã‚‹ã€‚",
  8: "å·¦å³ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Œã°\nå¿…ãšå‡ºã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚",
  9: "æš—åˆƒã®è€…ä»¥å¤–ã¯ç›®ã‚’é–‰ã˜ã€\nç™½è–”è–‡ã¨å¸æ•™ã®äºŒäººã¯èº«åˆ†ã‚’æ˜ã‹ã•ãšã«æ‰‹ã‚’ã‚ã’ã‚‹ã€‚",
  10:"å…¨å“¡ãŒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—çµ‚ã‚ã£ãŸå¾Œã«ã€ä¸€äººé¸ã¶ã€‚\nãã®äººã¯å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã‚’é•ã†ã‚«ãƒ¼ãƒ‰ã¨äº¤æ›ã™ã‚‹ã€‚",
  11:"æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚«ãƒ¼ãƒ‰ã‚’\nãƒ©ãƒ³ãƒ€ãƒ ã§ä¸€æšè¦‹ã‚‹ã€‚",
  12:"ã‚«ãƒ¼ãƒ‰ã‚’æŒã£ã¦ã„ã‚‹äººã‚’æŒ‡åã™ã‚‹ã€‚\nãã®äººã«å¼·åˆ¶çš„ã«ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã•ã›ã‚‹ã€‚"
};

function getPlayerCountForTargets(){
  // å„ªå…ˆï¼šãƒ›ã‚¹ãƒˆãŒé¸ã‚“ã  maxPlayersï¼ˆéƒ¨å±‹è¨­å®šï¼‰
  const maxP = Number(state.room?.maxPlayers || 0);
  if (maxP) return maxP;

  // æ¬¡ç‚¹ï¼šç¾åœ¨å‚åŠ äººæ•°
  const c = (state.players || []).length;
  return c || 0;
}

function getTargetsByPlayerCount(){
  const n = getPlayerCountForTargets();
  return CLEAR_TARGETS[n] || null;
}

function updateTargetBadges(){
  const t = getTargetsByPlayerCount();
  if (!aliveTargetBadge || !deadTargetBadge){
    return;
  }
  aliveTargetBadge.textContent = t ? String(t.alive) : '?';
  deadTargetBadge.textContent  = t ? String(t.dead)  : '?';
}

/* discardãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚«ãƒ¼ãƒ‰åé…åˆ—ã‚’æŠ½å‡ºï¼ˆé…åˆ—/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä¸¡å¯¾å¿œï¼‰ */
function extractCardNames(value, options = {}){
  const { skipDead = false } = options;
  if (!value) return [];
  if (Array.isArray(value)){
    return value.flatMap((v) => {
      if (skipDead && v && typeof v === 'object' && v.dead) return [];
      const name = typeof v === 'string' ? v : (v?.card ?? v?.name ?? null);
      return name ? [name] : [];
    });
  }
  if (typeof value === 'object'){
    // {key:{card:"å¸æ•™"}} / {0:"å¸æ•™"} ãªã©
    return Object.values(value).flatMap((v) => {
      if (skipDead && v && typeof v === 'object' && v.dead) return [];
      const name = typeof v === 'string' ? v : (v?.card ?? v?.name ?? null);
      return name ? [name] : [];
    });
  }
  return [];
}

function getDiscardCards(slotKey, options = {}){
  const d = state.discard || {};
  return extractCardNames(d[slotKey], options);
}

function countBelieverAndBishop(cards){
  let n = 0;
  for (const c of cards){
    if (c === 'å¸æ•™' || c === 'ä¿¡è€…') n++;
  }
  return n;
}

/* â˜…ç”Ÿå­˜ã‚¯ãƒªã‚¢æ¼”å‡ºï¼šç™½è–”è–‡ã‚’ä¸­å¤®æ‹¡å¤§ã—ã¦3ç§’ */
let aliveClearTimer = null;
function playAliveClearRose3s(){
  if (!aliveClearOverlay || !aliveClearCard) return;

  aliveClearCard.style.backgroundImage = `url('${ASSET.roleFront["ç™½è–”è–‡"] || "bara.jpg"}')`;

  aliveClearOverlay.classList.remove('hidden');
  aliveClearOverlay.classList.remove('play');
  void aliveClearOverlay.offsetWidth;
  aliveClearOverlay.classList.add('play');

  if (aliveClearTimer) clearTimeout(aliveClearTimer);
  aliveClearTimer = setTimeout(() => {
    aliveClearTimer = null;
    aliveClearOverlay.classList.add('hidden');
    aliveClearOverlay.classList.remove('play');
  }, 3400); // in(0.22s)+hold(3.0s) ã¶ã‚“ä½™è£•
}

/* â˜…ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ¼”å‡ºï¼šç™½è–”è–‡æ•£ã‚Šï¼‹èƒŒé¢ã‹ã‚‰æš—åˆƒ */
let gameOverTimer = null;
function playGameOverRoseDarkBlade(){
  if (!gameOverOverlay || !goRose || !goBlade || !goPieces) return;

  goRose.style.backgroundImage  = `url('${ASSET.roleFront["ç™½è–”è–‡"] || "bara.jpg"}')`;
  goBlade.style.backgroundImage = `url('${ASSET.roleFront["æš—åˆƒ"] || "anjin.jpg"}')`;

  // ç ´ç‰‡ç”Ÿæˆï¼ˆç™½è–”è–‡ï¼‰
  goPieces.innerHTML = '';
  const dirs = [
    {dx:-120, dy:-95, rot:-26},{dx:-45, dy:-140, rot:16},
    {dx: 55, dy:-135, rot:-12},{dx: 130, dy:-95, rot:22},
    {dx:-145, dy: 30, rot:20},{dx:-70, dy: 135, rot:-20},
    {dx: 78, dy: 140, rot:14},{dx: 150, dy: 35, rot:-22},
  ];
  for (let i=0;i<dirs.length;i++){
    const p = document.createElement('div');
    p.className = 'rb-piece';
    p.style.backgroundImage = `url('${ASSET.roleFront["ç™½è–”è–‡"] || "bara.jpg"}')`;
    p.style.setProperty('--dx', `${dirs[i].dx}px`);
    p.style.setProperty('--dy', `${dirs[i].dy}px`);
    p.style.setProperty('--rot', `${dirs[i].rot}deg`);
    goPieces.appendChild(p);
  }

  // å†ç”Ÿï¼ˆæ—¢å­˜ rb ã‚¢ãƒ‹ãƒ¡CSSã‚’ãã®ã¾ã¾åˆ©ç”¨ï¼‰
  gameOverOverlay.classList.remove('hidden');
  gameOverOverlay.classList.remove('play');
  void gameOverOverlay.offsetWidth;
  gameOverOverlay.classList.add('play');

  if (gameOverTimer) clearTimeout(gameOverTimer);
  gameOverTimer = setTimeout(() => {
    gameOverTimer = null;
    gameOverOverlay.classList.add('hidden');
    gameOverOverlay.classList.remove('play');
    goPieces.innerHTML = '';
  }, 3000);
}

/* â˜…æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã§é…ç½®å¾Œï¼ˆdiscardæ›´æ–°å¾Œï¼‰ã«åˆ¤å®šã—ã¦æ¼”å‡º */
function checkRoundEndConditionsAfterDiscardPlaced(){
  const started = !!state.game?.started;
  if (!started) return;

  const round = Number(state.game?.round || 0);
  if (!round) return;

  const t = getTargetsByPlayerCount();
  if (!t) return;

  const aliveCards = [
    ...getDiscardCards('alive'),
    ...getDiscardCards('rose', { skipDead: true }),
  ];
  const deadCards  = getDiscardCards('dead');

  const aliveBD = countBelieverAndBishop(aliveCards);
  const deadBD  = countBelieverAndBishop(deadCards);

  const hasRoseInAlive = aliveCards.includes('ç™½è–”è–‡');

  // â‘  ç”Ÿå­˜ã‚¯ãƒªã‚¢æ•°ã¶ã‚“å¸æ•™/ä¿¡è€…ãŒç”Ÿå­˜ã«ã„ã¦ã€ç™½è–”è–‡ãŒç”Ÿå­˜ã«ã‚ã‚‹ â†’ ç™½è–”è–‡æ‹¡å¤§3ç§’
  if (hasRoseInAlive && aliveBD >= t.alive){
    if (lastAliveClearAnimRound !== round){
      lastAliveClearAnimRound = round;
      playAliveClearRose3s();
    }
  }

  // â‘¡ æ­»äº¡è€…ãŒã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ•°ã«é”ã—ãŸ â†’ ç™½è–”è–‡æ•£ã‚Šï¼‹èƒŒé¢æš—åˆƒ
  if (deadBD >= t.dead){
    if (lastGameOverAnimRound !== round){
      lastGameOverAnimRound = round;
      playGameOverRoseDarkBlade();
    }
  }
}



function getHelpPlayerCount(){
  const maxPlayers = Number(state.room?.maxPlayers || 0);
  if (maxPlayers) return maxPlayers;
  return state.players?.length || 0;
}
function renderHelpList(){
  helpBody.innerHTML = '';

  const roundWrapper = document.createElement('div');
  roundWrapper.className = 'round-play-wrapper';
  roundWrapper.id = 'roundPlayWrapper';
  const roundTitle = document.createElement('div');
  roundTitle.className = 'round-play-title';
  roundTitle.textContent = 'ãƒ©ã‚¦ãƒ³ãƒ‰æå‡ºè¡¨';
  const roundTable = document.createElement('table');
  roundTable.className = 'round-play-table';
  roundTable.id = 'roundPlayTable';
  roundTable.setAttribute('aria-label', 'ãƒ©ã‚¦ãƒ³ãƒ‰æå‡ºè¡¨');
  roundWrapper.appendChild(roundTitle);
  roundWrapper.appendChild(roundTable);
  helpBody.appendChild(roundWrapper);

  roundPlayWrapper = roundWrapper;
  roundPlayTable = roundTable;
  renderRoundPlayTable();

  const roleSection = document.createElement('div');
  roleSection.className = 'help-section';
  const roleTitle = document.createElement('div');
  roleTitle.className = 'help-section-title';
  roleTitle.textContent = 'å½¹è·ã‚«ãƒ¼ãƒ‰';
  roleSection.appendChild(roleTitle);

  const playerCount = getHelpPlayerCount();
  const giantBladeCount = playerCount === 9 ? 1 : (playerCount === 10 ? 2 : null);
  const giantBladeDim = playerCount > 0 && playerCount < 7;

  const roleRows = [
    {
      name: 'ç™½è–”è–‡',
      images: ['ç™½è–”è–‡'],
      text: 'ã“ã®ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸæ™‚ã€ä»–ã«åˆƒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸäººãŒã„ã‚Œã°è² ã‘ã‚‹ã€‚ç™½è–”è–‡ã¨å¸æ•™ã¨åŒåˆƒã¨å·¨åˆƒã¯ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ç›®ã‚’åˆã‚ã›ã‚‹ï¼ˆå…·ä½“çš„ãªæ­£ä½“ã¾ã§ã¯çŸ¥ã‚‰ãªã„ï¼‰ã€‚'
    },
    {
      name: 'å¸æ•™',
      images: ['å¸æ•™'],
      text: 'å¸æ•™ã¨ä¿¡è€…ã‚’åˆã‚ã›ã¦ç‰¹å®šã®æ•°ãŒç”Ÿå­˜ã—ã€ã‹ã¤ç™½è–”è–‡ãŒç”Ÿå­˜ã™ã‚Œã°å‹ã¡ã€‚ç™½è–”è–‡ã¨å¸æ•™ã¨åŒåˆƒã¨å·¨åˆƒã¯ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ç›®ã‚’åˆã‚ã›ã‚‹ï¼ˆå…·ä½“çš„ãªæ­£ä½“ã¾ã§ã¯çŸ¥ã‚‰ãªã„ï¼‰ã€‚'
    },
    {
      name: 'ä¿¡è€…',
      images: ['ä¿¡è€…'],
      text: 'å¸æ•™ã¨ä¿¡è€…ã‚’åˆã‚ã›ã¦ç‰¹å®šã®æ•°ãŒç”Ÿå­˜ã—ã€ã‹ã¤ç™½è–”è–‡ãŒç”Ÿå­˜ã™ã‚Œã°å‹ã¡ã€‚'
    },
    {
      name: 'åŒåˆƒ',
      images: ['åŒåˆƒ', 'åŒåˆƒ', 'éœŠé­‚'],
      text: 'åŒåˆƒã®ã‚«ãƒ¼ãƒ‰ã‚’2æšæŒã£ã¦ã„ã‚‹ã€‚ç™½è–”è–‡ã¨å¸æ•™ã¨åŒåˆƒã¨å·¨åˆƒã¯ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ç›®ã‚’åˆã‚ã›ã‚‹ï¼ˆå…·ä½“çš„ãªæ­£ä½“ã¾ã§ã¯çŸ¥ã‚‰ãªã„ï¼‰ã€‚'
    },
    {
      name: 'æš—åˆƒ',
      images: ['æš—åˆƒ'],
      text: ''
    },
    {
      name: 'å·¨åˆƒ',
      images: ['å·¨åˆƒ'],
      text: 'ç™½è–”è–‡ã¨å¸æ•™ã¨åŒåˆƒã¨å·¨åˆƒã¯ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ç›®ã‚’åˆã‚ã›ã‚‹ï¼ˆå…·ä½“çš„ãªæ­£ä½“ã¾ã§ã¯çŸ¥ã‚‰ãªã„ï¼‰ã€‚',
      dim: giantBladeDim,
      count: giantBladeCount
    }
  ];

  roleRows.forEach((row) => {
    const wrapper = document.createElement('div');
    wrapper.className = 'role-row';

    const stack = document.createElement('div');
    stack.className = 'role-card-stack';
    row.images.forEach((key, idx) => {
      const card = document.createElement('div');
      card.className = 'role-card-mini';
      if (row.dim) card.classList.add('dim');
      card.style.backgroundImage = `url('${ASSET.roleFront[key] || ''}')`;
      if (row.count && idx === 0){
        const badge = document.createElement('div');
        badge.className = 'count-badge';
        badge.textContent = String(row.count);
        card.appendChild(badge);
      }
      stack.appendChild(card);
    });

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    const nameEl = document.createElement('div');
    nameEl.className = 'name';
    nameEl.textContent = row.name;
    const textEl = document.createElement('div');
    textEl.className = 'text';
    textEl.textContent = row.text;
    desc.appendChild(nameEl);
    desc.appendChild(textEl);

    wrapper.appendChild(stack);
    wrapper.appendChild(desc);
    roleSection.appendChild(wrapper);
  });

  const effectSection = document.createElement('div');
  effectSection.className = 'help-section';
  const effectTitle = document.createElement('div');
  effectTitle.className = 'help-section-title';
  effectTitle.textContent = '1ã€œ12 åŠ¹æœ';
  effectSection.appendChild(effectTitle);

  const grid = document.createElement('div');
  grid.className = 'help-effect-grid';
  for (let i = 1; i <= 12; i++){
    const card = document.createElement('div');
    card.className = 'help-effect-card';

    const num = document.createElement('div');
    num.className = 'help-effect-num';
    num.textContent = String(i);
    const text = document.createElement('div');
    text.className = 'help-effect-text';
    text.textContent = POWER_TEXT[i] || '';

    card.appendChild(num);
    card.appendChild(text);
    grid.appendChild(card);
  }
  effectSection.appendChild(grid);

  helpBody.appendChild(roleSection);
  helpBody.appendChild(effectSection);
}
function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

/* =========================
   ã‚«ãƒ¼ãƒ‰ç´ æ
   ========================= */
const ASSET = {
  roleFront: {
    "ç™½è–”è–‡": "bara.jpg",
    "å¸æ•™": "sikyo.jpg",
    "ä¿¡è€…": "shinja.jpg",
    "åŒåˆƒ": "double.jpg",
    "æš—åˆƒ": "anjin.jpg",
    "å·¨åˆƒ": "kyojin.jpg",
    "éœŠé­‚": "reikon.jpg"
  },
  roleBack: "baraura.jpg",
  passFront: "pass.png"
};

const ROLE_PRIORITY = {
  "ç™½è–”è–‡": 1,
  "å¸æ•™": 2,
  "ä¿¡è€…": 3,
  "åŒåˆƒ": 4,
  "æš—åˆƒ": 5,
  "å·¨åˆƒ": 6,
  "å¤§åˆƒ": 6,
  "éœŠé­‚": 7
};
const BLADE_SET = new Set(["åŒåˆƒ","æš—åˆƒ","å·¨åˆƒ","å¤§åˆƒ"]);

const CLEAR_TARGETS = {
  5:  { alive: 3, dead: 4 },
  6:  { alive: 4, dead: 4 },
  7:  { alive: 4, dead: 6 },
  8:  { alive: 5, dead: 6 },
  9:  { alive: 5, dead: 7 },
  10: { alive: 6, dead: 7 }
};

let lastAliveClearAnimRound = 0;
let lastGameOverAnimRound = 0;

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

/* UIãƒãƒƒãƒ— */
const ui = {
  nodeByUserId: new Map(),
  tagByUserId: new Map(),
  owncoinByUserId: new Map(),
  playedBackByUserId: new Map(),
  miniHandByUserId: new Map(),
  miniHandHitByUserId: new Map(),
  miniHandSquareByUserId: new Map(),

  coinEl: null,
  ownedCoinDotByOwnerId: new Map(),
};

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

/* =========================
   â˜…ãƒ­ãƒ¼ã‚«ãƒ«ï¼ˆè‡ªåˆ†ã ã‘ï¼‰çŠ¶æ…‹
   - åŠ¹æœ11å®Œäº†å¾Œã«ã€Œä¸‹ã®é»’ãƒãƒƒãƒ—ã€ã‚’æ¶ˆã™
   ========================= */
let lastRoundSeen = 0;
let hidePowerPopRound = null;
let peekTimer = null;

/* â˜…è¿½åŠ ï¼šå…¬é–‹æ¼”å‡ºï¼ˆç™½è–”è–‡ï¼‹åˆƒï¼‰ã‚’1ãƒ©ã‚¦ãƒ³ãƒ‰1å›ã ã‘ */
let lastRoseBladeAnimRound = 0;
let lastPhaseSeen = null;
let roseBladeDelayTimer = null;


function pickBladeNameFromPlays(){
  const plays = state.plays || {};
  let blade = null;

  // å„ªå…ˆï¼ˆåŒåˆƒâ†’æš—åˆƒâ†’å·¨åˆƒâ†’å¤§åˆƒï¼‰
  const prefer = ["åŒåˆƒ","æš—åˆƒ","å·¨åˆƒ","å¤§åˆƒ"];
  const found = new Set();

  for (const v of Object.values(plays)){
    if (!v || v.kind !== 'role') continue;
    if (BLADE_SET.has(v.card)) found.add(v.card);
  }
  for (const n of prefer){
    if (found.has(n)){ blade = n; break; }
  }
  return blade;
}

function shouldPlayRoseBladeAnimNow(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started) return false;

  // ã€Œå…¬é–‹æ™‚ã€ï¼ table ã«å…¥ã£ãŸç¬é–“ã‚’ç‹™ã†ï¼ˆå¿…è¦ãªã‚‰ reveal2 ã‚‚è¿½åŠ å¯ï¼‰
  if (phase !== 'table') return false;

  const round = Number(state.game?.round || 0);
  if (!round) return false;
  if (lastRoseBladeAnimRound === round) return false;

  // ç™½è–”è–‡ï¼‹åˆƒ ãŒåŒæ™‚ã«å‡ºã¦ã„ã‚‹ã‹ï¼ˆplaysã‹ã‚‰åˆ¤å®šï¼‰
  let hasRose = false;
  for (const v of Object.values(state.plays || {})){
    if (!v || v.kind !== 'role') continue;
    if (v.card === 'ç™½è–”è–‡') hasRose = true;
  }
  const blade = pickBladeNameFromPlays();
  if (!hasRose || !blade) return false;

  return true;
}

function playRoseBladeRevealAnim(){
  if (!roseBladeOverlay || !rbRose || !rbBlade || !rbPieces) return;

  const bladeName = pickBladeNameFromPlays();
  if (!bladeName) return;

  // ç”»åƒã‚»ãƒƒãƒˆ
  rbRose.style.backgroundImage = `url('${ASSET.roleFront["ç™½è–”è–‡"] || "bara.jpg"}')`;
  rbBlade.style.backgroundImage = `url('${ASSET.roleFront[bladeName] || ""}')`;

  // ç ´ç‰‡ç”Ÿæˆï¼ˆæ¯å›ä½œã‚Šç›´ã—ï¼‰
  rbPieces.innerHTML = '';
  const dirs = [
    {dx:-110, dy:-90, rot:-28},{dx:-40, dy:-130, rot:18},
    {dx: 45, dy:-120, rot:-14},{dx: 120, dy:-85, rot:26},
    {dx:-135, dy: 28, rot:22},{dx:-60, dy: 120, rot:-22},
    {dx: 70, dy: 125, rot:16},{dx: 140, dy: 30, rot:-26},
  ];

  for (let i=0;i<dirs.length;i++){
    const p = document.createElement('div');
    p.className = 'rb-piece';
    p.style.backgroundImage = `url('${ASSET.roleFront["ç™½è–”è–‡"] || "bara.jpg"}')`;
    p.style.setProperty('--dx', `${dirs[i].dx}px`);
    p.style.setProperty('--dy', `${dirs[i].dy}px`);
    p.style.setProperty('--rot', `${dirs[i].rot}deg`);
    rbPieces.appendChild(p);
  }

  // å†ç”Ÿ
  roseBladeOverlay.classList.remove('hidden');
  roseBladeOverlay.classList.remove('play');
  // reflow
  void roseBladeOverlay.offsetWidth;
  roseBladeOverlay.classList.add('play');

  // å¾Œå§‹æœ«
  setTimeout(() => {
    roseBladeOverlay.classList.add('hidden');
    roseBladeOverlay.classList.remove('play');
    rbPieces.innerHTML = '';
  }, 3000);
}



/* =========================
   è³¼èª­
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
    updateTargetBadges();

  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    updateGameUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    state.game = snap.val() || {};

    // â˜…ãƒ©ã‚¦ãƒ³ãƒ‰æ›´æ–°ã§ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
    const r = Number(state.game?.round || 0);
    if (r && r !== lastRoundSeen){
      lastRoundSeen = r;
      hidePowerPopRound = null;
      if (peekTimer){ clearTimeout(peekTimer); peekTimer = null; }
      peekOverlay.classList.add('hidden');
    }
    renderMyHand();

    updateGameUI();
    updatePowerBanner();
    updatePower7UI();
    maybeHostAdvanceRound();
    renderTableCards();
    renderPlays();

    // â˜…è¿½åŠ ï¼šå…¬é–‹æ™‚ã€Œç™½è–”è–‡ï¼‹åˆƒã€æ¼”å‡ºï¼ˆtableã«å…¥ã£ãŸç¬é–“â†’3ç§’å¾Œã«å†ç”Ÿï¼‰
    const phaseNow = state.game?.phase || 'collect';
    if (lastPhaseSeen !== phaseNow){
      lastPhaseSeen = phaseNow;

      // phaseãŒå¤‰ã‚ã£ãŸã‚‰äºˆç´„ã‚’ã‚¯ãƒªã‚¢ï¼ˆåˆ¥ãƒ•ã‚§ãƒ¼ã‚ºã¸ç§»å‹•ã—ãŸå ´åˆã®æš´ç™ºé˜²æ­¢ï¼‰
      if (roseBladeDelayTimer){
        clearTimeout(roseBladeDelayTimer);
        roseBladeDelayTimer = null;
      }

      if (shouldPlayRoseBladeAnimNow()){
        const roundNow = Number(state.game?.round || 0);
        lastRoseBladeAnimRound = roundNow;

        // ã€Œå…¬é–‹ã‚«ãƒ¼ãƒ‰ãŒå‡ºã¦ã‹ã‚‰3ç§’å¾Œã€ï¼ tableæç”»å¾Œã«3ç§’å¾…ã£ã¦å†ç”Ÿ
        roseBladeDelayTimer = setTimeout(() => {
          roseBladeDelayTimer = null;

          // å¿µã®ãŸã‚ï¼šã¾ã åŒã˜ãƒ©ã‚¦ãƒ³ãƒ‰ï¼†tableä¸­ãªã‚‰å†ç”Ÿ
          const r2 = Number(state.game?.round || 0);
          const ph2 = state.game?.phase || 'collect';
          if (r2 === roundNow && ph2 === 'table'){
            playRoseBladeRevealAnim();
          }
        }, 2000);
      }
    }



    applyPlayableAnimToMyHand();

    // â˜…è¿½åŠ ï¼šåŠ¹æœ11çŸ¢å°ï¼ˆå…¨å“¡ï¼‰æ›´æ–°
    renderPower11Arrow();
    // â˜…è¿½åŠ ï¼šé¸æŠãƒ¢ãƒ¼ãƒ‰æ›´æ–°ï¼ˆåŠ¹æœ11 / 1 / 12ï¼‰
    updateSelectModeUI();
    // â˜…è¿½åŠ ï¼šåŠ¹æœ5ãƒªãƒ³ã‚¯æ›´æ–°
    renderPower5Link();
    maybeResetPower5Link();
    updateHandmarks(); 
    updateMiniHandSquares();
  });
}
function subscribePlays(){
  const playsRef = ref(db, `rooms/${state.roomCode}/plays`);
  onValue(playsRef, snap => {
    state.plays = snap.val() || {};
    renderPlays();
    updatePowerBanner();
    updatePower7UI();
    maybeHostAdvanceRound();
    applyPlayableAnimToMyHand();
    updateSelectModeUI();
    updatePower10UI();
    renderPower5Link();
    maybeApplyPower5AutoPass();
    maybeRefreshPower5PassUI();
    renderMyHand();

    // â˜…åŠ¹æœ3/4
    maybeTriggerPower34AutoPlays();
    maybeFinishPower34Shuffle();
  });

}
function subscribeRoundPlays(){
  const roundPlaysRef = ref(db, `rooms/${state.roomCode}/roundPlays`);
  onValue(roundPlaysRef, snap => {
    state.roundPlays = snap.val() || {};
    renderRoundPlayTable();
  });
}
function subscribeCoins(){
  const coinsRef = ref(db, `rooms/${state.roomCode}/coins`);
  onValue(coinsRef, snap => {
    state.coins = snap.val() || {};
    renderCoins();
    renderOwnedCoinsBadges();
    updatePowerBanner();
    updatePower7UI();
    applyPlayableAnimToMyHand();
    maybeResetPower5Link();
  });
}
function subscribeDiscard(){
  const dRef = ref(db, `rooms/${state.roomCode}/discard`);
  onValue(dRef, snap => {
    state.discard = snap.val() || {};
    renderDiscardTable();
    updateTargetBadges();
    checkRoundEndConditionsAfterDiscardPlaced();
  });
}

function isEveryoneDecided(){
  const playerCount = (state.players || []).length;
  if (playerCount <= 0) return false;
  const playedCount = Object.keys(state.plays || {}).length;
  return playedCount === playerCount;
}

/* =========================
   â˜…åº§å¸­ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   ========================= */
function getSeatIndexByUid(uid){
  return (state.players || []).find(p => p.id === uid)?.seatIndex ?? null;
}
function getUidBySeatIndex(seatIndex){
  return (state.players || []).find(p => p.seatIndex === seatIndex)?.id || null;
}
function getMaxSeatCount(){
  const maxPlayers = Number(state.room?.maxPlayers || 0);
  const playerCount = (state.players || []).length;
  return maxPlayers > 0 ? maxPlayers : playerCount;
}
function wrapSeatIndex(seatIndex){
  const max = getMaxSeatCount();
  if (!max) return null;
  const idx = ((seatIndex - 1) % max + max) % max;
  return idx + 1;
}
function getClockwiseDistanceFrom(ownerId, uid){
  const ownerSeat = getSeatIndexByUid(ownerId);
  const targetSeat = getSeatIndexByUid(uid);
  const max = getMaxSeatCount();
  if (ownerSeat == null || targetSeat == null || !max) return null;
  return ((targetSeat - ownerSeat) % max + max) % max;
}
function getPower5OrderInfo(p5){
  if (!p5 || !Array.isArray(p5.targets) || p5.targets.length !== 2) return null;
  const [a, b] = p5.targets;
  if (!a || !b || !p5.ownerId) return null;
  const da = getClockwiseDistanceFrom(p5.ownerId, a);
  const db = getClockwiseDistanceFrom(p5.ownerId, b);
  if (da == null || db == null) return null;
  if (da === db) return null;
  return da < db ? { firstId: a, secondId: b } : { firstId: b, secondId: a };
}
function getRightUid(uid){
  const seatIndex = getSeatIndexByUid(uid);
  if (seatIndex == null) return null;
  const nextSeat = wrapSeatIndex(seatIndex + 1);
  if (nextSeat == null) return null;
  return getUidBySeatIndex(nextSeat);
}
function getLeftUid(uid){
  const seatIndex = getSeatIndexByUid(uid);
  if (seatIndex == null) return null;
  const prevSeat = wrapSeatIndex(seatIndex - 1);
  if (prevSeat == null) return null;
  return getUidBySeatIndex(prevSeat);
}

function getSeatAngleDeg(uid){
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒ¼ãƒ‰ã¨å††ã®ä¸­å¿ƒã‹ã‚‰ã€ã‚«ãƒ¼ãƒ‰ã®ã€Œä¸Šè¾ºã€ãŒå††ã®ä¸­å¿ƒã‚’å‘ãè§’åº¦ã‚’ç®—å‡º
  const node = ui.nodeByUserId.get(uid);
  if (!node || !playerCircle) return 0;

  const circleRect = playerCircle.getBoundingClientRect();
  const cx = circleRect.left + circleRect.width / 2;
  const cy = circleRect.top + circleRect.height / 2;

  const r = node.getBoundingClientRect();
  const px = r.left + r.width / 2;
  const py = r.top + r.height / 2;

  // ãƒ™ã‚¯ãƒˆãƒ«ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½® â†’ å††ã®ä¸­å¿ƒ
  const rad = Math.atan2(cy - py, cx - px);
  // 0deg = ä¸Šå‘ããªã®ã§ +90deg ã—ã¦ã€Œä¸Šè¾ºã€ãŒä¸­å¿ƒã‚’å‘ãã‚ˆã†ã«
  const deg = rad * 180 / Math.PI + 90;
  return deg;
}

function updatePlayedCardAngles(){
  // å½¹ã‚«ãƒ¼ãƒ‰ï¼ˆè£é¢ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼‰ã ã‘ã€ä¸Šè¾ºã‚’å††ã®ä¸­å¿ƒã«å‘ã‘ã‚‹
  for (const [uid, el] of ui.playedBackByUserId){
    if (!el) continue;
    const deg = getSeatAngleDeg(uid);
    el.style.transform = `translate(-50%,-50%) rotate(${deg}deg)`;
  }
}


/* =========================
   â˜…åŠ¹æœ3/4ã€Œé¸ã¹ãªã„ã€åˆ¤å®šï¼ˆæ‰‹é †ã¯æ™‚è¨ˆå›ã‚Šï¼‰
   - 3: forced=å·¦ã®äººï¼ˆ=é¸ã¹ãªã„ï¼‰
   - 4: forced=å³ï¼ˆæ¬¡æ‰‹ç•ªï¼‰ï¼ˆ=é¸ã¹ãªã„ï¼‰
   ========================= */
function getDisabledUidByPower34(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  if (!started || phase !== 'collect') return null;
  if (!pd || !pd.ownerId) return null;
  const num = Number(pd.number);
  if (num === 3) return getLeftUid(pd.ownerId);
  if (num === 4) return getRightUid(pd.ownerId);
  return null;
}
function isMyPlayLockedByPower34(){
  const disabledUid = getDisabledUidByPower34();
  return !!(disabledUid && disabledUid === state.userId);
}

/* =========================
   â˜…è¿½åŠ ï¼šåŠ¹æœ8 / åŠ¹æœ1&12 ã®ã€Œâœ•ã‚«ãƒ¼ãƒ‰ã‚’éè¡¨ç¤ºã€åˆ¤å®š
   - 8: ownerï¼ˆpowerDisplayï¼‰å·¦å³ã®äººï¼ˆæ‰‹æœ­ãŒ1æšä»¥ä¸Šã‚ã‚‹å ´åˆã®ã¿ï¼‰
   - 1/12: ownerãŒé¸ã‚“ã 1äººï¼ˆæ‰‹æœ­ãŒ1æšä»¥ä¸Šã‚ã‚‹å ´åˆã®ã¿ï¼‰
   ========================= */
function getRoleCount(uid){
  const hd = state.hands?.[uid];
  const arr = (hd && Array.isArray(hd.roleCards)) ? hd.roleCards : [];
  return arr.length;
}
function hasLostCrystalChip(uid){
  return !!(uid && state.game?.chipLosses && state.game.chipLosses[uid]);
}
function updateMiniHandSquares(){
  for (const [uid, square] of ui.miniHandSquareByUserId){
    square.classList.toggle('hidden', hasLostCrystalChip(uid));
  }
}
function isCoinOwnerChangeRequired(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return false;
  const lastOwner = state.game?.lastCoinOwnerId || null;
  if (!lastOwner) return false;
  const currentOwner = state.coins?.[COIN_ID]?.ownerId ?? null;
  return currentOwner === lastOwner;
}
function isPassHiddenForUid(uid){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return false;

  // æ‰‹æœ­0ãªã‚‰ã€âœ•ã¯å¿…è¦ï¼ˆè©°ã¿é˜²æ­¢ï¼‰ãªã®ã§éš ã•ãªã„
  if (getRoleCount(uid) <= 0) return false;

  const pd = state.game?.powerDisplay || null;

  // åŠ¹æœ8
  if (pd && Number(pd.number) === 8 && pd.ownerId){
    const left = getLeftUid(pd.ownerId);
    const right = getRightUid(pd.ownerId);
    if (uid === left || uid === right) return true;
  }

  // åŠ¹æœ1/12ï¼ˆé¸ã°ã‚ŒãŸäººï¼‰
  const p112 = state.game?.power112 || null;
  const round = Number(state.game?.round || 0);
  if (p112 && p112.used && Number(p112.round || 0) === round){
    if (p112.targetId && p112.targetId === uid) return true;
  }

  // åŠ¹æœ5ï¼ˆå…ˆã®äººãŒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸã‚‰å¾Œã®äººã¯âœ•éè¡¨ç¤ºï¼‰
  const p5 = getPower5State();
  if (p5 && p5.used){
    const order = getPower5OrderInfo(p5);
    if (order && order.secondId === uid){
      const firstPlay = state.plays?.[order.firstId] || null;
      if (firstPlay && firstPlay.kind === 'role') return true;
    }
  }

  return false;
}

/* =========================
   â˜…åŠ¹æœ11 / åŠ¹æœ1&12 ã®ã€Œä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­ã‚’é¸ã¶ã€ãƒ¢ãƒ¼ãƒ‰
   ========================= */
function isMyPowerDisplay(number){
  const pd = state.game?.powerDisplay || null;
  if (!pd) return false;
  if (pd.ownerId !== state.userId) return false;
  return Number(pd.number) === Number(number);
}
function isMyPower11Selectable(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return false;
  if (!isMyPowerDisplay(11)) return false;
  const p11 = state.game?.power11 || null;
  const round = Number(state.game?.round || 0);
  if (p11 && p11.used && Number(p11.round || 0) === round && p11.ownerId === state.userId) return false;
  return true;
}
function isMyPower112Selectable(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return false;
  const pd = state.game?.powerDisplay || null;
  if (!pd || pd.ownerId !== state.userId) return false;
  const n = Number(pd.number);
  if (!(n === 1 || n === 12)) return false;

  const p112 = state.game?.power112 || null;
  const round = Number(state.game?.round || 0);
 if (p112 && p112.used && Number(p112.round || 0) === round && p112.ownerId === state.userId) return false;
  return true;
}

// ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã§æ‰‹æœ­ãŒ1æšä»¥ä¸Šã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ•°ãˆã‚‹é–¢æ•°
function countOtherPlayersWithHands() {
    let count = 0;
    for (const p of (state.players || [])) {
        if (p.id === state.userId) continue; // è‡ªåˆ†ã¯é™¤å¤–
        if (hasLostCrystalChip(p.id)) continue; // æ°´æ™¶ãƒãƒƒãƒ—ã‚’å¤±ã£ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯é™¤å¤–
        if (getRoleCount(p.id) > 0) { // æ‰‹æœ­ãŒ1æšä»¥ä¸Š
            count++;
        }
    }
    return count;
}


function getPower5State(){
  const p5 = state.game?.power5 || null;
  if (!p5) return null;
  const round = Number(state.game?.round || 0);
  if (Number(p5.round || 0) !== round) return null;
  return p5;
}
function isPower5SelectionLocked(){
  if (!isMyPowerDisplay(5)) return false;
  const myPlay = state.plays?.[state.userId] || null;
  if (!myPlay) return false;
  const playedAt = Number(myPlay.playedAt || 0);
  const shownAt = Number(state.game?.powerDisplay?.shownAt || 0);
  if (shownAt > playedAt) return false;
  return true;
}
function isPower5SelectionIncomplete() {
    const started = !!state.game?.started;
    const phase = state.game?.phase || 'collect';
    if (!started || phase !== 'collect') return false;
    const pd = state.game?.powerDisplay || null;
    if (!pd || Number(pd.number) !== 5) return false;
    
    // â˜…å¤‰æ›´ç®‡æ‰€ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã§æ‰‹æœ­ãŒ1æšä»¥ä¸Šã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ2äººä»¥ä¸Šã„ãªã„å ´åˆã¯falseã‚’è¿”ã™
    // ã“ã‚Œã«ã‚ˆã‚Šã€é¸æŠãŒå®Œäº†ã—ã¦ã„ãªãã¦ã‚‚æå‡ºã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„
    if (countOtherPlayersWithHands() < 2) return false;
    
    const p5 = getPower5State();
    if (!p5 || p5.ownerId !== pd.ownerId) return true;
    const targets = Array.isArray(p5.targets) ? p5.targets : [];
    return targets.length < 2;
}



function isMyPlayLockedByPower5Pass(){
  const p5 = getPower5State();
  if (!p5 || !p5.used) return false;
  const order = getPower5OrderInfo(p5);
  if (!order) return false;
  if (order.secondId !== state.userId) return false;
  const firstPlay = state.plays?.[order.firstId] || null;
  return !!(firstPlay && firstPlay.kind === 'pass');
}
function isMyPlayLockedByPower5Waiting(){
  const p5 = getPower5State();
  if (!p5 || !p5.used) return false;
  const order = getPower5OrderInfo(p5);
  if (!order) return false;
  if (order.secondId !== state.userId) return false;
  const firstPlay = state.plays?.[order.firstId] || null;
  return !firstPlay;
}
function isMyPower5Selectable() {
    const started = !!state.game?.started;
    const phase = state.game?.phase || 'collect';
    if (!started || phase !== 'collect') return false;
    if (!isMyPowerDisplay(5)) return false;
    if (isPower5SelectionLocked()) return false;
    
    // â˜…å¤‰æ›´ç®‡æ‰€ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã§æ‰‹æœ­ãŒ1æšä»¥ä¸Šã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ2äººä»¥ä¸Šã„ãªã„å ´åˆã¯é¸æŠä¸å¯
    if (countOtherPlayersWithHands() < 2) return false;
    
    return true;
}


function getPower10State(){
  const p10 = state.game?.power10 || null;
  if (!p10) return null;
  const round = Number(state.game?.round || 0);
  if (Number(p10.round || 0) !== round) return null;
  return p10;
}
function isMyPower10Selecting(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'power10') return false;
  const pd = state.game?.powerDisplay || null;
  if (!pd || pd.ownerId !== state.userId) return false;
  if (Number(pd.number) !== 10) return false;
  const p10 = getPower10State();
  if (!p10 || p10.status !== 'selecting') return false;
  return p10.ownerId === state.userId;
}
function isPower10ChangeAllowed(uid = state.userId){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'power10') return false;
  const p10 = getPower10State();
  if (!p10 || p10.status !== 'awaiting-change') return false;
  if (p10.targetId !== uid) return false;
  if (p10.changeDone) return false;
  return true;
}
function isSelectingOtherHandsNow(){
  return isMyPower11Selectable() || isMyPower112Selectable() || isMyPower10Selecting() || isMyPower5Selectable();
}


/* â˜…é¸æŠãƒ¢ãƒ¼ãƒ‰UIï¼šãƒŸãƒ‹æ‰‹æœ­ã®ãƒ‘ãƒ«ã‚¹ï¼†å½“ãŸã‚Šåˆ¤å®š */
function updateSelectModeUI() {
    const selectingPower10 = isMyPower10Selecting();
    const selectingOther = isMyPower11Selectable() || isMyPower112Selectable();
    const selectingPower5 = isMyPower5Selectable(); // å¤‰æ›´ã•ã‚ŒãŸé–¢æ•°ã‚’ä½¿ç”¨

    for (const p of (state.players || [])) {
        if (p.id === state.userId) continue;

        const miniHand = ui.miniHandByUserId.get(p.id);
        const hit = ui.miniHandHitByUserId.get(p.id);

        const hasCards = (getRoleCount(p.id) > 0);
        const hasRolePlay = state.plays?.[p.id]?.kind === 'role';
        let enable = false;
        if (selectingPower10) {
            enable = hasCards && hasRolePlay;
        } else if (selectingOther) {
            enable = hasCards;
        } else if (selectingPower5) {
            // â˜…å¤‰æ›´ç®‡æ‰€ï¼šhasCards ã¨ selectingPower5 ã®ä¸¡æ–¹ãŒtrueã®å ´åˆã®ã¿æœ‰åŠ¹
            enable = hasCards && selectingPower5;
        }

        if (miniHand) {
            miniHand.classList.toggle('selectable', enable);
        }
        if (hit) {
            hit.classList.toggle('active', enable);
        }
    }
}

function hidePower10Confirm(){
  power10ConfirmPop.classList.add('hidden');
  pendingPower10TargetId = null;
  pendingPower10TargetName = null;
}

function showPower10ConfirmAt(clientX, clientY){
  if (!pendingPower10TargetId) return;
  power10ConfirmName.textContent = pendingPower10TargetName || 'èª°ã‹';
  power10ConfirmPop.style.left = `${clientX}px`;
  power10ConfirmPop.style.top = `${clientY}px`;
  power10ConfirmPop.classList.remove('hidden');

  requestAnimationFrame(() => {
    const rect = power10ConfirmPop.getBoundingClientRect();
    const pad = 12;
    let x = clientX;
    let y = clientY;
    if (rect.left < pad) x += (pad - rect.left);
    if (rect.right > window.innerWidth - pad) x -= (rect.right - (window.innerWidth - pad));
    if (rect.top < pad) y += (pad - rect.top);
    if (rect.bottom > window.innerHeight - pad) y -= (rect.bottom - (window.innerHeight - pad));
    power10ConfirmPop.style.left = `${x}px`;
    power10ConfirmPop.style.top = `${y}px`;
  });
}

/* â˜…åŠ¹æœ11ï¼šè¦—ãè¦‹è¡¨ç¤º */
function showPeek(cardName){
  const url = ASSET.roleFront[cardName] || '';
  peekCard.style.backgroundImage = url ? `url('${url}')` : '';
  peekLabel.textContent = cardName || 'â€”';
  peekOverlay.classList.remove('hidden');
}
function hidePeek(){
  peekOverlay.classList.add('hidden');
}

/* â˜…åŠ¹æœ11ï¼šçŸ¢å°æç”»ï¼ˆå…¨å“¡ï¼‰ */
let arrowRaf = null;
function stopArrowLoop(){
  if (arrowRaf){
    cancelAnimationFrame(arrowRaf);
    arrowRaf = null;
  }
}
function ensureArrowSvgSize(){
  // clientåº§æ¨™ã§ä½¿ã†ã®ã§ viewBox ã‚’ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
  const w = window.innerWidth || 1;
  const h = window.innerHeight || 1;
  arrowSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);
}
window.addEventListener('resize', () => { ensureArrowSvgSize(); renderPower11Arrow(); });
function renderPower11Arrow(){
  ensureArrowSvgSize();

  const p11 = state.game?.power11 || null;
  const round = Number(state.game?.round || 0);
  const now = Date.now();

  const active =
    !!p11 &&
    !!p11.used &&
    Number(p11.round || 0) === round &&
    !!p11.ownerId &&
    !!p11.toUid &&
    Number(p11.endsAt || 0) > now;

  if (!active){
    arrowLayer.classList.add('hidden');
    stopArrowLoop();
    return;
  }

  const fromUid = p11.ownerId;
  const toUid = p11.toUid;

  arrowLayer.classList.remove('hidden');

  const tick = () => {
    const p11now = state.game?.power11 || null;
    const now2 = Date.now();
    if (!p11now || !p11now.used || Number(p11now.round || 0) !== round || Number(p11now.endsAt || 0) <= now2){
      arrowLayer.classList.add('hidden');
      stopArrowLoop();
      return;
    }

    const fromTag = ui.tagByUserId.get(fromUid);
    const toTag = ui.tagByUserId.get(toUid);
    if (!fromTag || !toTag){
      arrowLayer.classList.add('hidden');
      stopArrowLoop();
      return;
    }

    const r1 = fromTag.getBoundingClientRect();
    const r2 = toTag.getBoundingClientRect();

    const x1 = r1.left + r1.width/2;
    const y1 = r1.top  + r1.height/2;
    const x2 = r2.left + r2.width/2;
    const y2 = r2.top  + r2.height/2;

    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.max(1, Math.hypot(dx, dy));
    const pad = 28;

    const sx = x1 + (dx/len) * pad;
    const sy = y1 + (dy/len) * pad;
    const ex = x2 - (dx/len) * pad;
    const ey = y2 - (dy/len) * pad;

    arrowLine.setAttribute('x1', String(sx));
    arrowLine.setAttribute('y1', String(sy));
    arrowLine.setAttribute('x2', String(ex));
    arrowLine.setAttribute('y2', String(ey));

    const mx = (sx + ex)/2;
    const my = (sy + ey)/2;
    arrowEye.setAttribute('x', String(mx));
    arrowEye.setAttribute('y', String(my));

    arrowRaf = requestAnimationFrame(tick);
  };

  if (!arrowRaf){
    arrowRaf = requestAnimationFrame(tick);
  }
}

/* â˜…åŠ¹æœ5ï¼šèµ¤ç‚¹ç·šãƒªãƒ³ã‚¯ï¼ˆå…¨å“¡ï¼‰ */
let power5LinkRaf = null;
function stopPower5LinkLoop(){
  if (power5LinkRaf){
    cancelAnimationFrame(power5LinkRaf);
    power5LinkRaf = null;
  }
}
function ensurePower5SvgSize(){
  const w = window.innerWidth || 1;
  const h = window.innerHeight || 1;
  power5LinkSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);
}
window.addEventListener('resize', () => { ensurePower5SvgSize(); renderPower5Link(); });

function updatePower5TagSelection(){
  for (const tag of ui.tagByUserId.values()){
    tag.classList.remove('power5-selected');
  }

  const pd = state.game?.powerDisplay || null;
  if (!pd || Number(pd.number) !== 5) return;

  const p5 = getPower5State();
  if (!p5 || p5.ownerId !== pd.ownerId) return;
  const targets = Array.isArray(p5.targets) ? p5.targets : [];

  for (const uid of targets){
    const tag = ui.tagByUserId.get(uid);
    if (tag) tag.classList.add('power5-selected');
  }
}

function renderPower5Link(){
  ensurePower5SvgSize();

  const p5 = getPower5State();
  const round = Number(state.game?.round || 0);
  const pd = state.game?.powerDisplay || null;

  updatePower5TagSelection();

  const active =
    !!p5 &&
    !!p5.used &&
    Number(p5.round || 0) === round &&
    !!pd &&
    Number(pd.number) === 5 &&
    pd.ownerId === p5.ownerId &&
    Array.isArray(p5.targets) &&
    p5.targets.length === 2;
  if (!active){
    power5LinkLayer.classList.add('hidden');
    stopPower5LinkLoop();
    return;
  }

  const [uidA, uidB] = p5.targets;
  power5LinkLayer.classList.remove('hidden');

  const tick = () => {
    const p5now = getPower5State();
    const activeNow =
      !!p5now &&
      !!p5now.used &&
      Array.isArray(p5now.targets) &&
      p5now.targets.length === 2;

    if (!activeNow){
      power5LinkLayer.classList.add('hidden');
      stopPower5LinkLoop();
      return;
    }

    const tagA = ui.tagByUserId.get(uidA);
    const tagB = ui.tagByUserId.get(uidB);
    if (!tagA || !tagB){
      power5LinkLayer.classList.add('hidden');
      stopPower5LinkLoop();
      return;
    }

    const r1 = tagA.getBoundingClientRect();
    const r2 = tagB.getBoundingClientRect();

    const x1 = r1.left + r1.width/2;
    const y1 = r1.top  + r1.height/2;
    const x2 = r2.left + r2.width/2;
    const y2 = r2.top  + r2.height/2;

    power5LinkLine.setAttribute('x1', String(x1));
    power5LinkLine.setAttribute('y1', String(y1));
    power5LinkLine.setAttribute('x2', String(x2));
    power5LinkLine.setAttribute('y2', String(y2));
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    power5LinkBow.setAttribute('x', String(mx));
    power5LinkBow.setAttribute('y', String(my));

    power5LinkRaf = requestAnimationFrame(tick);
  };

  if (!power5LinkRaf){
    power5LinkRaf = requestAnimationFrame(tick);
  }
}

async function maybeResetPower5Link(){
  if (!state.roomCode || !state.isHost) return;
  const p5 = state.game?.power5 || null;
  if (!p5) return;
  const round = Number(state.game?.round || 0);
  if (Number(p5.round || 0) !== round) return;

  const pd = state.game?.powerDisplay || null;
  const powerIsFive = !!pd && Number(pd.number) === 5 && !!pd.ownerId;
  const hasCoin = !!(state.coins && Object.prototype.hasOwnProperty.call(state.coins, COIN_ID));
  const coinOwner = hasCoin ? (state.coins?.[COIN_ID]?.ownerId ?? null) : null;
  const coinMismatch = hasCoin && coinOwner !== pd?.ownerId;

  if (powerIsFive && !coinMismatch) return;

  await set(ref(db, `rooms/${state.roomCode}/game/power5`), null);
}



/* â˜…å…±é€šï¼šä»–äººãƒŸãƒ‹æ‰‹æœ­ã‚¯ãƒªãƒƒã‚¯ */
async function onOtherHandClicked(targetUid, event){
  if (!state.roomCode) return;
  if (targetUid === state.userId) return;
  if (isCoinOwnerChangeRequired()) return;

  // åŠ¹æœ10
  if (isMyPower10Selecting()){
    const play = state.plays?.[targetUid] || null;
    if (!play || play.kind !== 'role') return;
    if (getRoleCount(targetUid) <= 0) return;

    const targetName = (state.players || []).find(p => p.id === targetUid)?.name || 'èª°ã‹';
    pendingPower10TargetId = targetUid;
    pendingPower10TargetName = targetName;

    showPower10ConfirmAt(event?.clientX ?? 0, event?.clientY ?? 0);
   return;
  }

  // åŠ¹æœ5
  if (isMyPower5Selectable()){
    if (getRoleCount(targetUid) <= 0) return;

    const now = Date.now();
    const round = Number(state.game?.round || 1);

    await runTransaction(ref(db, `rooms/${state.roomCode}/game/power5`), (cur) => {
      const pd = state.game?.powerDisplay || null;
      if (!pd || pd.ownerId !== state.userId || Number(pd.number) !== 5) return cur || null;

      const c = cur || {};
      const currentRound = Number(c.round || 0);
      let targets = Array.isArray(c.targets) ? [...c.targets] : [];

      if (currentRound !== round || c.ownerId !== state.userId){
        targets = [];
      }

      if (targets.includes(targetUid)){
        targets = targets.filter(id => id !== targetUid);
      } else {
        if (targets.length >= 2) return c;
        targets.push(targetUid);
      }

      const used = targets.length >= 2;

      return {
        round,
        ownerId: state.userId,
        targets,
        used,
        chosenAt: used ? now : (c.chosenAt || null)
      };
    });

    updateSelectModeUI();
    renderPower5Link();
    return;
  }

  // åŠ¹æœ11
  if (isMyPower11Selectable()){
    // å¯¾è±¡ã®æ‰‹æœ­ã‚’DBã‹ã‚‰å–å¾—ã—ã¦ãƒ©ãƒ³ãƒ€ãƒ 1æšè¦—ãè¦‹ï¼ˆã‚«ãƒ¼ãƒ‰ã¯å‹•ã‹ã•ãªã„ï¼‰
    const snap = await get(ref(db, `rooms/${state.roomCode}/hands/${targetUid}/roleCards`));
    const arr0 = snap.val();
    const arr = Array.isArray(arr0) ? arr0 : [];
    if (!arr.length) return;

    const pick = arr[Math.floor(Math.random() * arr.length)];
    const now = Date.now();
    const round = Number(state.game?.round || 1);

    // power11ï¼ˆçŸ¢å°ï¼‰ã‚’1å›ã ã‘ç¢ºå®š
    await runTransaction(ref(db, `rooms/${state.roomCode}/game/power11`), (cur) => {
      const pd = state.game?.powerDisplay || null;
      if (!pd || pd.ownerId !== state.userId || Number(pd.number) !== 11) return cur || null;

      const c = cur || {};
      if (c.used && Number(c.round || 0) === round && c.ownerId === state.userId) return c;

      return {
        round,
        ownerId: state.userId,
        toUid: targetUid,
        used: true,
        shownAt: now,
        endsAt: now + 4000
      };
    });

    // è‡ªåˆ†ã ã‘ä¸­å¤®ã«4ç§’è¡¨ç¤º
    showPeek(pick);
    if (peekTimer){ clearTimeout(peekTimer); }
    peekTimer = setTimeout(() => {
      peekTimer = null;
      hidePeek();

      // â˜…æŒ‡å®šï¼šã“ã®å‡¦ç†ã®å¾Œã€Œä¸‹ã®èª¬æ˜é»’ãƒãƒƒãƒ—ã€ã‚’æ¶ˆã™
      hidePowerPopRound = Number(state.game?.round || 0);
      renderMyHand(); // ã™ãåæ˜ 
    }, 4000);

    updateSelectModeUI();
    renderPower11Arrow();
    return;
  }

  // åŠ¹æœ1 / 12
  if (isMyPower112Selectable()){
    const pd = state.game?.powerDisplay || null;
    const now = Date.now();
    const round = Number(state.game?.round || 1);

    // å¯¾è±¡ãŒæ‰‹æœ­ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼ˆå³å¯†ã«DBã§ç¢ºèªï¼‰
    const snap = await get(ref(db, `rooms/${state.roomCode}/hands/${targetUid}/roleCards`));
    const arr0 = snap.val();
    const arr = Array.isArray(arr0) ? arr0 : [];
    if (!arr.length) return;

    await runTransaction(ref(db, `rooms/${state.roomCode}/game/power112`), (cur) => {
      const pdNow = state.game?.powerDisplay || null;
      if (!pdNow || pdNow.ownerId !== state.userId) return cur || null;
      const n = Number(pdNow.number);
      if (!(n === 1 || n === 12)) return cur || null;

      const c = cur || {};
      if (c.used && Number(c.round || 0) === round && c.ownerId === state.userId) return c;

      return {
        round,
        ownerId: state.userId,
        number: Number(pdNow.number),
        targetId: targetUid,
        used: true,
        chosenAt: now
      };
    });

    updateSelectModeUI();
    renderMyHand(); // è‡ªåˆ†ç”»é¢ã®è¡¨ç¤ºã¯å¤‰ã‚ã‚‰ãªã„ãŒã€ã‚¿ã‚¤ãƒŸãƒ³ã‚°çš„ã«å‘¼ã¶
    return;
  }
}

/* =========================
   â˜…åŠ¹æœ5 è‡ªå‹•âœ•ï¼âœ•éè¡¨ç¤º
   ========================= */
async function maybeApplyPower5AutoPass(){
  const p5 = getPower5State();
  if (!p5 || !p5.used) return;
  const order = getPower5OrderInfo(p5);
  if (!order) return;
  const firstPlay = state.plays?.[order.firstId] || null;
  if (!firstPlay || firstPlay.kind !== 'pass') return;
  if (order.secondId !== state.userId) return;
  const myPlay = state.plays?.[state.userId] || null;
  if (myPlay && myPlay.kind === 'pass') return;
  await setMyPlay({ kind:'pass' });
}

function maybeRefreshPower5PassUI(){
  const p5 = getPower5State();
  if (!p5 || !p5.used) return;
  const order = getPower5OrderInfo(p5);
  if (!order) return;
  if (order.secondId !== state.userId) return;
  renderMyHand();
}



/* =========================
   â˜…åŠ¹æœ3/4 å¼·åˆ¶æå‡ºï¼ˆ6ç§’å¾…æ©Ÿï¼‹å¯¾è±¡ã‚¯ãƒªãƒƒã‚¯ã§å³å®Ÿè¡Œï¼‰
   ï¼ˆã“ã“ã‹ã‚‰ä¸‹ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒã—ã¤ã¤ã€ãã®ã¾ã¾ï¼‰
   ========================= */
let power34ShuffleActive = false;
let power34ShuffleCleanupTimer = null;
let lastPower34AnimAt = 0;
let power34WaitTimer = null;
let power34WaitKey = null;

function clearPower34WaitTimer(){
  if (power34WaitTimer){
    clearTimeout(power34WaitTimer);
    power34WaitTimer = null;
  }
  power34WaitKey = null;
}

function clearPower34ShuffleOverlay(){
  if (power34ShuffleCleanupTimer){
    clearTimeout(power34ShuffleCleanupTimer);
    power34ShuffleCleanupTimer = null;
  }
  if (!power34ShuffleOverlay) return;
  power34ShuffleOverlay.classList.remove('stacked', 'show');
  power34ShuffleOverlay.innerHTML = '';
  myHandEl.classList.remove('power34-hidden');
  power34ShuffleActive = false;
}

function startPower34ShuffleAnim(){
  if (!power34ShuffleOverlay || power34ShuffleActive) return;
  const cards = Array.from(myHandEl.querySelectorAll('.role-card'));
  if (!cards.length) return;

  const handRect = myHandEl.getBoundingClientRect();
  const sampleRect = cards[0].getBoundingClientRect();
  const stackX = handRect.left + handRect.width / 2 - sampleRect.width / 2;
  const stackY = handRect.top + Math.min(handRect.height * 0.45, 50);

  power34ShuffleOverlay.innerHTML = '';
  power34ShuffleOverlay.classList.add('show');
  myHandEl.classList.add('power34-hidden');

  cards.forEach((card, idx) => {
    const rect = card.getBoundingClientRect();
    const overlay = document.createElement('div');
    overlay.className = 'power34-shuffle-card';
    overlay.style.width = `${rect.width}px`;
    overlay.style.height = `${rect.height}px`;
    overlay.style.left = `${rect.left}px`;
    overlay.style.top = `${rect.top}px`;
    overlay.style.backgroundImage = `url('${ASSET.roleBack}')`;
    const dx = stackX - rect.left;
    const dy = stackY - rect.top;
    const rot = (Math.random() * 18 - 9).toFixed(1);
    overlay.style.setProperty('--tx', `${dx}px`);
    overlay.style.setProperty('--ty', `${dy}px`);
    overlay.style.setProperty('--rot', `${rot}deg`);
    overlay.style.zIndex = String(560 + idx);
    power34ShuffleOverlay.appendChild(overlay);
  });

  power34ShuffleActive = true;
  requestAnimationFrame(() => {
    power34ShuffleOverlay.classList.add('stacked');
  });
}

function endPower34ShuffleAnim(){
  if (!power34ShuffleActive || !power34ShuffleOverlay) return;
  power34ShuffleOverlay.classList.remove('stacked');
  power34ShuffleCleanupTimer = setTimeout(() => {
    clearPower34ShuffleOverlay();
  }, 520);
}

/** â˜…ç¾åœ¨ã® power34 æ–‡è„ˆï¼ˆå®Ÿè¡Œåˆ¤å®šã«å¿…è¦ãªæƒ…å ±ã‚’ä¸€ç®‡æ‰€ã§ç®—å‡ºï¼‰ */
function getPower34Context(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return null;

  const pd = state.game?.powerDisplay || null;
  if (!pd || !pd.ownerId) return null;

  const num = Number(pd.number);
  if (num !== 3 && num !== 4) return null;

  const round = Number(state.game?.round || 1);
  const ownerId = pd.ownerId;

  const forcedUid = (num === 3) ? getLeftUid(ownerId) : getRightUid(ownerId);
  if (!forcedUid) return null;

  const triggerUid = (num === 3) ? getLeftUid(forcedUid) : ownerId;
  if (!triggerUid) return null;

  const triggerPlay = state.plays?.[triggerUid] || null;
  if (!triggerPlay) return null;

  const triggerAt = Number(triggerPlay.playedAt || 0);
  if (!triggerAt) return null;

  const scheduledAt = triggerAt + 6000;

  return { round, ownerId, num, forcedUid, triggerUid, triggerAt, scheduledAt };
}

/** â˜…å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã€Œè‡ªåˆ†ã®æ‰‹æœ­ã‚’1å›ã‚¯ãƒªãƒƒã‚¯ã€ã—ãŸå°ï¼ˆDBã«æ®‹ã—ã¦å…¨ç«¯æœ«ã§å³å®Ÿè¡Œã¸ï¼‰ */
async function markPower34ForcedClicked(){
  if (!state.roomCode) return;
  const ctx = getPower34Context();
  if (!ctx) return;
  if (ctx.forcedUid !== state.userId) return;
  if (state.plays?.[ctx.forcedUid]) return;

  const base = `rooms/${state.roomCode}`;
  const p34Ref = ref(db, `${base}/game/power34`);
  const now = Date.now();

  await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    const same =
      c.round === ctx.round &&
      c.ownerId === ctx.ownerId &&
      Number(c.number) === ctx.num &&
      c.triggerUid === ctx.triggerUid &&
      c.forcedUid === ctx.forcedUid &&
      Number(c.triggerAt) === ctx.triggerAt;

    if (!same){
      return {
        round: ctx.round,
        ownerId: ctx.ownerId,
        number: ctx.num,
        triggerUid: ctx.triggerUid,
        forcedUid: ctx.forcedUid,
        triggerAt: ctx.triggerAt,
        scheduledAt: ctx.scheduledAt,
        clickedAt: now,
        done: false,
        claimedBy: null,
        claimedAt: null,
        animAt: null,
        forcedCard: null,
        result: null
      };
    }

    if (c.done) return c;
    if (c.clickedAt) return c;
    c.clickedAt = now;
    return c;
  });

  // ã‚¯ãƒªãƒƒã‚¯ã‚’ä»˜ã‘ãŸã‚‰å³æ™‚åˆ¤å®šï¼ˆå®Ÿè¡Œã¸ï¼‰
  maybeTriggerPower34AutoPlays();
}

/** â˜…å®Ÿè¡Œæœ¬ä½“ï¼ˆå®‰å…¨å´ï¼šå¤±æ•—æ™‚ã®å¾©æ—§ã‚‚è¡Œã†ï¼‰ */
async function executePower34Now(ctx){
  const base = `rooms/${state.roomCode}`;
  const p34Ref = ref(db, `${base}/game/power34`);

  // ã™ã§ã«æå‡ºæ¸ˆã¿ãªã‚‰çµ‚äº†
  const already = (await get(ref(db, `${base}/plays/${ctx.forcedUid}`))).val();
  if (already){
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'already_played' });
    return;
  }

  const handRef = ref(db, `${base}/hands/${ctx.forcedUid}/roleCards`);
  const handSnap = await get(handRef);
  const roleCards0 = handSnap.val();
  let roleCards = Array.isArray(roleCards0) ? [...roleCards0] : [];
  if (!roleCards.length){
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'nohand' });
    return;
  }

  // p34å´ã« forcedCard ãŒæ—¢ã«ã‚ã‚Œã°å„ªå…ˆï¼ˆä¸ä¸€è‡´ãªã‚‰ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
  const p34Now = (await get(p34Ref)).val() || {};
  let pick = (p34Now.forcedCard && roleCards.includes(p34Now.forcedCard)) ? p34Now.forcedCard : null;
  if (!pick){
    pick = roleCards[Math.floor(Math.random() * roleCards.length)];
  }

  // animAt / forcedCard ã‚’ç¢ºå®šï¼ˆè¤‡æ•°ç«¯æœ«ã§ã‚‚æœ€åˆã®ã‚‚ã®ã‚’å°Šé‡ï¼‰
  await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    if (c.done) return c;
    if (!c.forcedCard) c.forcedCard = pick;
    if (!c.animAt) c.animAt = Date.now();
    return c;
  });

  // â˜…å‰Šé™¤ã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ2å›ã ã‘å®‰å…¨ãƒªãƒˆãƒ©ã‚¤ï¼‰
  let removed = false;
  let finalPick = pick;

  for (let attempt=0; attempt<2; attempt++){
    const tx = await runTransaction(handRef, (current) => {
      const arr = Array.isArray(current) ? [...current] : [];
      const idx = arr.indexOf(finalPick);
      if (idx === -1) return; // å¤±æ•— â†’ committed=false
      arr.splice(idx, 1);
      return arr;
    });

    if (tx.committed){
      removed = true;
      break;
    }

    // å¤±æ•—ã—ãŸã‚‰æœ€æ–°æ‰‹æœ­ã§é¸ã³ç›´ã—ï¼ˆæ‰‹æœ­æ¶ˆæ»…ã‚’é¿ã‘ã‚‹ï¼‰
    const hs = await get(handRef);
    const a0 = hs.val();
    const a = Array.isArray(a0) ? [...a0] : [];
    if (!a.length){
      await update(p34Ref, { done:true, doneAt: Date.now(), result:'nohand' });
      return;
    }
    finalPick = a[Math.floor(Math.random() * a.length)];
    await runTransaction(p34Ref, (cur) => {
      const c = cur || {};
      if (c.done) return c;
      if (!c.forcedCard) c.forcedCard = finalPick;
      return c;
    });
  }

  if (!removed){
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'fail_remove' });
    return;
  }

  // plays ã«ã‚»ãƒƒãƒˆï¼ˆå¤±æ•—ã—ãŸã‚‰æ‰‹æœ­ã¸æˆ»ã™ï¼æ¶ˆæ»…é˜²æ­¢ï¼‰
  const forcedSeat = (state.players || []).find(p => p.id === ctx.forcedUid)?.seatIndex || 0;

  try{
   await set(ref(db, `${base}/plays/${ctx.forcedUid}`), {
      kind: 'role',
      card: finalPick,
      seatIndex: forcedSeat,
      playedAt: Date.now(),
      forcedBy: 'power34',
      forcedFrom: ctx.num
    });
  } catch (e){
    // å¾©æ—§ï¼šæ‰‹æœ­ã¸æˆ»ã™ï¼ˆé‡è¤‡é˜²æ­¢ã®ãŸã‚å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã—ã¦ã‹ã‚‰pushï¼‰
    await runTransaction(handRef, (current) => {
      const arr = Array.isArray(current) ? [...current] : [];
      if (!arr.includes(finalPick)) arr.push(finalPick);
      return arr;
    });
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'fail_setplay_restore' });
    return;
  }

  await update(p34Ref, { done:true, doneAt: Date.now(), result:'ok', forcedCard: finalPick });
}

/** â˜…ç›£è¦–ï¼šæ¡ä»¶ã‚’æº€ãŸã—ãŸã‚‰ï¼ˆ6ç§’çµŒé or clickedAtï¼‰1å›ã ã‘ claim ã—ã¦å®Ÿè¡Œ */
async function maybeTriggerPower34AutoPlays(){
  if (!state.roomCode) return;

  const ctx = getPower34Context();
  if (!ctx){
    clearPower34WaitTimer();
    return;
  }

  // forcedãŒæ—¢ã«æå‡ºã—ã¦ã‚‹ãªã‚‰ä¸è¦
  if (state.plays?.[ctx.forcedUid]){
    clearPower34WaitTimer();
    return;
  }

  const base = `rooms/${state.roomCode}`;
  const p34Ref = ref(db, `${base}/game/power34`);

  // â˜…p34 æ–‡è„ˆã‚’æ•´å‚™ï¼ˆã‚ºãƒ¬ã¦ãŸã‚‰ä½œã‚Šç›´ã™ï¼‰
  await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    const same =
      c.round === ctx.round &&
      c.ownerId === ctx.ownerId &&
      Number(c.number) === ctx.num &&
      c.triggerUid === ctx.triggerUid &&
      c.forcedUid === ctx.forcedUid &&
      Number(c.triggerAt) === ctx.triggerAt;

    if (!same){
      return {
        round: ctx.round,
        ownerId: ctx.ownerId,
        number: ctx.num,
        triggerUid: ctx.triggerUid,
        forcedUid: ctx.forcedUid,
        triggerAt: ctx.triggerAt,
        scheduledAt: ctx.scheduledAt,
        clickedAt: null,
        done: false,
        claimedBy: null,
        claimedAt: null,
        animAt: null,
        forcedCard: null,
        result: null
      };
    }

    // scheduledAt ãŒç„¡ã„/å¤‰ãªã‚‰è£œæ­£
    if (!c.scheduledAt || Number(c.scheduledAt) !== ctx.scheduledAt){
      c.scheduledAt = ctx.scheduledAt;
    }
    return c;
  });

  const snap = await get(p34Ref);
  const p34 = snap.val() || null;
  if (!p34){
    clearPower34WaitTimer();
    return;
  }

  if (p34.done){
    clearPower34WaitTimer();
    return;
  }

  // ã™ã§ã«æå‡ºã•ã‚Œã¦ã„ãŸã‚‰doneã«ã—ã¦çµ‚äº†
  const playsNow = (await get(ref(db, `${base}/plays/${ctx.forcedUid}`))).val();
  if (playsNow){
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'already_played' });
    clearPower34WaitTimer();
    return;
  }

  const now = Date.now();
  const scheduledAt = Number(p34.scheduledAt || ctx.scheduledAt);
  const clickedAt = Number(p34.clickedAt || 0);

  const readyByTime = now >= scheduledAt;
  const readyByClick = !!clickedAt && clickedAt >= ctx.triggerAt;

  if (!readyByTime && !readyByClick){
    // â˜…ã¾ã å¾…æ©Ÿ â†’ scheduledAt ã§èµ·å‹•
    const remain = Math.max(0, scheduledAt - now);
    const key = `${ctx.round}|${ctx.num}|${ctx.ownerId}|${ctx.triggerUid}|${ctx.forcedUid}|${ctx.triggerAt}|${scheduledAt}`;
    if (power34WaitKey !== key){
      clearPower34WaitTimer();
      power34WaitKey = key;
      power34WaitTimer = setTimeout(() => {
        power34WaitTimer = null;
        power34WaitKey = null;
        maybeTriggerPower34AutoPlays();
      }, remain + 40);
    }
    return;
  } else {
    clearPower34WaitTimer();
  }

  // â˜…claimï¼ˆreadyæ¡ä»¶ã‚’æº€ãŸã—ãŸæ™‚ã ã‘ï¼‰
  const claim = await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    if (c.done) return c;

    const sAt = Number(c.scheduledAt || ctx.scheduledAt);
    const cAt = Number(c.clickedAt || 0);
    const ready = (Date.now() >= sAt) || (!!cAt && cAt >= ctx.triggerAt);
    if (!ready) return c;

    if (c.claimedBy) return c;

    c.claimedBy = state.userId;
    c.claimedAt = Date.now();
    c.execReason = (Date.now() >= sAt) ? 'time' : 'click';
    return c;
  });

  const claimed = claim.snapshot.val() || null;
  if (!claim.committed || !claimed) return;
  if (claimed.claimedBy !== state.userId) return;

  await executePower34Now(ctx);
}

/* â˜… power34.animAt ã‚’è³¼èª­ã—ã¦æ¼”å‡ºè¡¨ç¤º */
function subscribePower34Anim(){
  const p34Ref = ref(db, `rooms/${state.roomCode}/game/power34`);
  onValue(p34Ref, snap => {
    const v = snap.val();
    if (!v) return;
    const started = !!state.game?.started;
    const phase = state.game?.phase || 'collect';
    if (!started || phase !== 'collect') return;

    if (v.animAt && typeof v.animAt === 'number' && v.forcedUid === state.userId){
      if (v.animAt > lastPower34AnimAt && Date.now() - v.animAt < 3000){
        lastPower34AnimAt = v.animAt;
        startPower34ShuffleAnim();
      }
    }
  });
}
function maybeFinishPower34Shuffle(){
  if (!power34ShuffleActive) return;
  const play = state.plays?.[state.userId];
  if (!play) return;
  if (play.forcedBy === 'power34'){
    endPower34ShuffleAnim();
  }
}

/* =========================
   â˜…ãƒ—ãƒ¬ã‚¤å¯èƒ½ãªæ‰‹æœ­ãªã‚‰å¤§å°ã‚¢ãƒ‹ãƒ¡
   ï¼ˆåŠ¹æœ3/4ã§é¸ã¹ãªã„äººã¯ playable ã‚’ä»˜ã‘ãªã„ï¼‰
   ========================= */
function isRolePlayableNow() {
    if (!state.game?.started) return false;
    const phase = state.game?.phase || 'collect';
    if (phase !== 'collect') {
        return isPower10ChangeAllowed();
    }
    if (isCoinOwnerChangeRequired()) return false;
    if (isPower5SelectionIncomplete()) return false; // ã“ã“ã§å¤‰æ›´ã•ã‚ŒãŸé–¢æ•°ã‚’ä½¿ç”¨
    if (isEveryoneDecided()) return false;
    if (isMyPlayLockedByPower34()) return false;
    if (isMyPlayLockedByPower5Waiting()) return false;
    if (isMyPlayLockedByPower5Pass()) return false;
    return true;
}

function applyPlayableAnimToMyHand(){
  const playable = isRolePlayableNow();
  myHandEl.querySelectorAll('.role-card').forEach(el => {
    el.classList.toggle('playable', playable);
  });
}

/* â˜…å¤‰æ›´ï¼šã‚³ã‚¤ãƒ³ownå¾Œã®ãƒãƒŠãƒ¼ã¯ã€Œå…¬é–‹ï¼ˆtable/reveal2ï¼‰ã¾ã§ã€è¡¨ç¤ºã—ç¶šã‘ã‚‹ */
function updatePowerBanner(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;

  const shouldShow = started && !!pd && (phase !== 'table') && (phase !== 'reveal2');
  powerBanner.classList.toggle('hidden', !shouldShow);
  if (!shouldShow) return;

  const ownerId = pd.ownerId;
  const number = Number(pd.number);
  const ownerName = (state.players || []).find(p => p.id === ownerId)?.name || 'èª°ã‹';

  powerBannerNum.textContent = (Number.isFinite(number) ? String(number) : '?');
  powerBannerText.textContent = POWER_TEXT[number] || '';
}

function updatePower10UI(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const p10 = getPower10State();
  const isActive = started && phase === 'power10' && !!p10;

  const isOwnerSelecting = isActive && p10.status === 'selecting' && p10.ownerId === state.userId;
  power10OwnerPop.classList.toggle('hidden', !isOwnerSelecting);

  const isTargetWaiting =
    isActive &&
    p10.status === 'awaiting-change' &&
    p10.targetId === state.userId &&
    !p10.changeDone;
  power10TargetPop.classList.toggle('hidden', !isTargetWaiting);

  if (!isOwnerSelecting){
    hidePower10Confirm();
  }
  if (!isActive){
    power10SkipDialog.classList.add('hidden');
  }
}

function updateGameUI(){
  const started = !!state.game.started;
  coinPool.classList.toggle('hidden', !started);

  const phase = state.game.phase || 'collect';

  tableArea.classList.toggle('show', started && phase === 'table');

  btnNextRound.classList.toggle('visible', !!(started && state.isHost && (phase === 'table' || phase === 'reveal2')));

  applyPlayableAnimToMyHand();
  updatePower10UI();

  if (started){
    requestAnimationFrame(() => {
      renderCoins();
      renderOwnedCoinsBadges();
    });
  }

}

let coinWarningTimer = null;
function showCoinWarningPop(){
  if (!coinWarningPop) return;
  coinWarningPop.classList.remove('hidden');
  if (coinWarningTimer) clearTimeout(coinWarningTimer);
  coinWarningTimer = setTimeout(() => {
    coinWarningPop.classList.add('hidden');
  }, 1600);
}

async function maybeClearCoinOwnerChangeLock(newOwnerId){
  const lastOwner = state.game?.lastCoinOwnerId || null;
  if (!lastOwner) return;
  if (newOwnerId === lastOwner) return;
  if (!state.roomCode) return;
  await update(ref(db, `rooms/${state.roomCode}/game`), { lastCoinOwnerId: null });
}


function renderHands(){
  renderMyHand();
  renderRoundPlayTable();
  if (state.players.length) renderPlayerCircle(state.players);
  renderPlays();
  renderCoins();
  renderOwnedCoinsBadges();
  renderDiscardTable();
  renderTableCards();
  updatePower7UI();
  updateSelectModeUI();
  renderPower11Arrow();
  renderPower5Link();
}

function renderRoundPlayTable(){
  if (!roundPlayWrapper || !roundPlayTable) return;

  const players = state.players || [];
  const roundCount = players.length;
  if (!roundCount){
    roundPlayWrapper.classList.add('hidden');
    roundPlayTable.innerHTML = '';
    return;
  }

  roundPlayWrapper.classList.remove('hidden');
  roundPlayTable.innerHTML = '';

  const thead = document.createElement('thead');
  const headRow = document.createElement('tr');
  const nameTh = document.createElement('th');
  nameTh.textContent = 'åå‰';
  headRow.appendChild(nameTh);

  for (let r = 1; r <= roundCount; r += 1){
    const th = document.createElement('th');
    th.textContent = `R${r}`;
    headRow.appendChild(th);
  }
  thead.appendChild(headRow);

  const tbody = document.createElement('tbody');
  const roundData = state.roundPlays || {};

  players.forEach(player => {
    const row = document.createElement('tr');
    const nameCell = document.createElement('td');
    nameCell.className = 'round-play-name';
    nameCell.textContent = player.name || 'åç„¡ã—';
    row.appendChild(nameCell);

    for (let r = 1; r <= roundCount; r += 1){
      const cell = document.createElement('td');
      cell.className = 'round-play-cell';
      const roundKey = String(r);
      const play = roundData?.[roundKey]?.[player.id] || null;

      if (play && play.kind === 'role'){
        const back = document.createElement('div');
        back.className = 'round-play-card-back';
        if (play.card && play.revealed){
          back.style.backgroundImage = `url('${ASSET.roleFront[play.card] || ''}')`;
        } else {
          back.style.backgroundImage = `url('${ASSET.roleBack}')`;
        }
        cell.appendChild(back);
      } else if (play && play.kind === 'pass'){
        const mark = document.createElement('div');
        mark.className = 'round-play-pass';
        mark.textContent = 'âœ•';
        cell.appendChild(mark);
      }
      row.appendChild(cell);
    }
    tbody.appendChild(row);
  });

  roundPlayTable.appendChild(thead);
  roundPlayTable.appendChild(tbody);
}


function renderMyHand(){
  myHandEl.innerHTML = '';

  const myId = state.userId;
  const handData = state.hands[myId];
  const started = !!state.game.started;
  const lostCrystal = hasLostCrystalChip(myId);


  maybeAutoPassWhenNoHand();
  if (started && handData) {
    const roleCards = Array.isArray(handData.roleCards) ? handData.roleCards : [];
    const hasRoleCards = roleCards.length > 0;
    const hasPlayedRoleThisRound = state.plays?.[myId]?.kind === 'role';
    roleCards.forEach((name, idx) => {
      const card = document.createElement('div');
      card.className = 'role-card';
      card.dataset.role = name;
      card.dataset.index = String(idx);

      const face = document.createElement('div');
      face.className = 'face';
      face.style.backgroundImage = `url('${ASSET.roleFront[name] || ''}')`;

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = name;

      card.appendChild(face);
      card.appendChild(label);

      // â˜…æ—¢å­˜ï¼šãƒ‰ãƒ©ãƒƒã‚°æå‡º
      card.addEventListener('pointerdown', (e) => startDragCard(e, { kind:'role', cardName:name }));

      // â˜…è¿½åŠ ï¼ˆæœ€å°ï¼‰ï¼špower34å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã€Œè‡ªåˆ†ã®æ‰‹æœ­ã‚’1å›ã‚¯ãƒªãƒƒã‚¯ã€â†’å³å®Ÿè¡Œ
     card.addEventListener('click', (e) => {
        if (!state.game?.started) return;
        if (isCoinOwnerChangeRequired()) return;
        const ctx = getPower34Context();
        if (!ctx) return;
        if (ctx.forcedUid !== state.userId) return; // å¯¾è±¡ä»¥å¤–ã¯ç„¡é–¢ä¿‚
        if (state.plays?.[state.userId]) return;
        markPower34ForcedClicked();
      });

      myHandEl.appendChild(card);
    });

    // â˜…å‡ºã•ãªã„ï¼ˆâœ•ï¼‰ã‚«ãƒ¼ãƒ‰ï¼šåŠ¹æœ8 / åŠ¹æœ1&12 ã§ã€Œéè¡¨ç¤ºã€ã«ãªã‚‹
    const passShouldShow =
      (hasRoleCards || hasPlayedRoleThisRound) &&
      !isPassHiddenForUid(myId) &&
      !isPower10ChangeAllowed(myId) &&
      !isPower5SelectionIncomplete() &&
      !isMyPlayLockedByPower5Waiting();

    if (passShouldShow){
      const pass = document.createElement('div');
      pass.className = 'pass-card';
      pass.dataset.pass = "1";
      pass.innerHTML = `<div class="label">å‡ºã•ãªã„</div>`;
      pass.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (isCoinOwnerChangeRequired()) return;
        if (isPower5SelectionIncomplete()) return;
        if (isMyPlayLockedByPower5Waiting()) return;
        if (isMyPlayLockedByPower5Pass()) return;
        await setMyPlay({ kind:'pass' });
      });
      myHandEl.appendChild(pass);
    }
  }

  // â˜…ä¸‹ã®é»’ãƒãƒƒãƒ—ï¼ˆpowerWrapperï¼‰ã¯ã€åŠ¹æœ11å®Œäº†å¾Œã¯ãã®ãƒ©ã‚¦ãƒ³ãƒ‰ã ã‘æ¶ˆã™
  const myRound = Number(state.game?.round || 0);
  const shouldHidePowerPop = (hidePowerPopRound != null && hidePowerPopRound === myRound);

  if (started && handData && handData.numberCard && !shouldHidePowerPop && !lostCrystal) {
    const n = Number(handData.numberCard);
    powerWrapper.style.display = '';
    powerCardEl.textContent = String(n);
    powerTextEl.textContent = POWER_TEXT[n] || '';
    fitTextToBox(powerTextEl, 14, 9);
  } else {
    powerWrapper.style.display = 'none';
  }

  applyPlayableAnimToMyHand();
}

let autoPassNoHandInFlight = false;
async function maybeAutoPassWhenNoHand(){
  if (autoPassNoHandInFlight) return;
  if (isSettingMyPlay) return;
  if (!state.roomCode) return;
  if (!state.userId) return;



  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return;

  if (state.plays?.[state.userId]) return;

  const handData = state.hands?.[state.userId];
  const roleCards = (handData && Array.isArray(handData.roleCards)) ? handData.roleCards : [];
  if (roleCards.length > 0) return;

  autoPassNoHandInFlight = true;
  try {
    const seatIndex = state.seatedTable || 0;
    await set(ref(db, `rooms/${state.roomCode}/plays/${state.userId}`), {
      kind: 'pass',
      card: null,
      seatIndex,
      playedAt: Date.now()
    });
  } finally {
    autoPassNoHandInFlight = false;
  }
}


function fitTextToBox(spanEl, maxPx=14, minPx=9){
  if (!spanEl) return;
  const box = spanEl.parentElement;
  if (!box) return;

  let size = maxPx;
  spanEl.style.fontSize = size + 'px';
  while (size > minPx && (spanEl.scrollHeight > box.clientHeight || spanEl.scrollWidth > box.clientWidth)) {
    size -= 1;
    spanEl.style.fontSize = size + 'px';
  }
}

/* =========================
   å…¥å®¤
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || 'åç„¡ã—';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeGame();
  subscribePlays();
  subscribeRoundPlays();
  subscribeCoins();
  subscribeDiscard();

  // â˜…è¿½åŠ ï¼špower34.animè³¼èª­
  subscribePower34Anim();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„', url);
  }
});

/* =========================
   ç€å¸­UI
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = 'äººæ•°ã‚’é¸æŠ';
      for(let i=2; i<=10; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = 'å¸­ã‚’é¸æŠ';

    const effectiveMax = maxPlayers || 10;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è³¼èª­ & å††æç”»
   ========================= */
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || 'åç„¡ã—',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    state.players = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
    renderPlays();
    renderCoins();
    renderOwnedCoinsBadges();
    updatePowerBanner();
    updatePower7UI();
    renderMyHand();
    renderRoundPlayTable();

    maybeHostAdvanceRound();
    applyPlayableAnimToMyHand();

    // â˜…è¿½åŠ 
    updateSelectModeUI();
    renderPower11Arrow();
  });
}

/* =========================
   â˜…è¿½åŠ ï¼šåˆå›é…å¸ƒå½¹è·ã®ã€Œç›¸äº’ğŸ¤šğŸ»è¡¨ç¤ºã€
   - è¦‹ãˆã‚‹äººï¼šç™½è–”è–‡/å¸æ•™/å¤§åˆƒ/åŒåˆƒ ã‚’æŒã¤äººã ã‘
   - è¡¨ç¤ºå¯¾è±¡ï¼šä¸Šè¨˜4å½¹ã® â€œè‡ªåˆ†ä»¥å¤–â€ ã®ãƒãƒ¼ãƒ ã‚¿ã‚°
   - ä½ç½®ï¼šãƒãƒ¼ãƒ ã‚¿ã‚°å·¦å¤–
   ========================= */
const HANDMARK_GROUP = new Set(["ç™½è–”è–‡","å¸æ•™","å¤§åˆƒ","åŒåˆƒ"]);

function getStartRoleUids(roleName){
  const sr = state.game?.startRoles?.roleToUids || null;
  const arr = sr ? sr[roleName] : null;
  return Array.isArray(arr) ? arr : [];
}
function isUidInHandmarkGroup(uid){
  for (const r of HANDMARK_GROUP){
    if (getStartRoleUids(r).includes(uid)) return true;
  }
  return false;
}

function updateHandmarks(){
  // ã„ã£ãŸã‚“å…¨å“¡ã®ğŸ¤šğŸ»ã‚’æ¶ˆã™
  for (const [uid, tag] of ui.tagByUserId.entries()){
    const old = tag.querySelector('.handmark');
    if (old) old.remove();
  }

  // ã‚²ãƒ¼ãƒ æœªé–‹å§‹ / åˆå›é…å¸ƒæƒ…å ±ãªã— â†’ ä½•ã‚‚ã—ãªã„
  if (!state.game?.started) return;
  if (!state.game?.startRoles?.roleToUids) return;

  const me = state.userId;
  const roleToUids = state.game.startRoles.roleToUids;

  // =========================
  // â˜…è¿½åŠ ï¼šownplayer(=powerDisplay) ãŒ 9 ã®ã¨ã
  // æš—åˆƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ãŒã€ç™½è–”è–‡ï¼†å¸æ•™ã®ã‚¿ã‚°å·¦ã«ğŸ¤šğŸ»ã‚’ä»˜ã‘ã¦è¦‹ãˆã‚‹
  // =========================
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  const power9Active = (phase === 'collect') && !!pd && (Number(pd.number) === 9);

  const anjinUids = Array.isArray(roleToUids["æš—åˆƒ"]) ? roleToUids["æš—åˆƒ"] : [];
  const isMeAnjin = anjinUids.includes(me);

  if (power9Active && isMeAnjin){
    const roseUids = Array.isArray(roleToUids["ç™½è–”è–‡"]) ? roleToUids["ç™½è–”è–‡"] : [];
    const bishopUids = Array.isArray(roleToUids["å¸æ•™"]) ? roleToUids["å¸æ•™"] : [];

    const targets = new Set([...roseUids, ...bishopUids]);
    targets.delete(me);

    for (const uid of targets){
      const tag = ui.tagByUserId.get(uid);
      if (!tag) continue;
      if (tag.querySelector('.handmark')) continue; // å¿µã®ãŸã‚äºŒé‡é˜²æ­¢

      const mark = document.createElement('span');
      mark.className = 'handmark';
      mark.textContent = 'ğŸ¤šğŸ»';
      tag.appendChild(mark);
    }
  }

  // =========================
  // æ—¢å­˜ï¼šåˆå›é…å¸ƒå½¹è·ã®ã€Œç›¸äº’ğŸ¤šğŸ»è¡¨ç¤ºã€
  // ï¼ˆç™½è–”è–‡/å¸æ•™/å¤§åˆƒ/åŒåˆƒã‚’æŒã¤äººã ã‘ãŒã€åŒã‚°ãƒ«ãƒ¼ãƒ—ã®ä»–äººã«ğŸ¤šğŸ»ï¼‰
  // =========================

  // è‡ªåˆ†ãŒã‚°ãƒ«ãƒ¼ãƒ—å¤–ãªã‚‰è¦‹ãˆãªã„ï¼ˆèª°ã«ã‚‚ä»˜ã‘ãªã„ï¼‰
  if (!isUidInHandmarkGroup(me)) return;

  // ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®ã€Œè‡ªåˆ†ä»¥å¤–ã€ã®ã‚¿ã‚°å·¦å¤–ã«ğŸ¤šğŸ»
  for (const p of (state.players || [])){
    if (!p || !p.id) continue;
    if (p.id === me) continue;
    if (!isUidInHandmarkGroup(p.id)) continue;

    const tag = ui.tagByUserId.get(p.id);
    if (!tag) continue;
    if (tag.querySelector('.handmark')) continue; // â˜…è¿½åŠ ï¼šäºŒé‡é˜²æ­¢ï¼ˆåŠ¹æœ9ã¨ç«¶åˆã—ãªã„ï¼‰

    const mark = document.createElement('span');
    mark.className = 'handmark';
    mark.textContent = 'ğŸ¤šğŸ»';
    tag.appendChild(mark);
  }
}


function renderPlayerCircle(players){
  playerCircle.querySelectorAll('.player-node').forEach(el => el.remove());
  ui.nodeByUserId.clear();
  ui.tagByUserId.clear();
  ui.owncoinByUserId.clear();
  ui.miniHandByUserId.clear();
  ui.miniHandHitByUserId.clear();
  ui.miniHandSquareByUserId.clear();

  if (!players.length) return;

  const n = players.length;
  const radiusPct = 44;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radiusPct * Math.cos(angle);
    const y = 50 + radiusPct * Math.sin(angle);

    const node = document.createElement('div');
    node.className = 'player-node';
    node.dataset.uid = p.id;
    node.style.left = `${x}%`;
    node.style.top  = `${y}%`;

    const owncoin = document.createElement('div');
    owncoin.className = 'owncoin';

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;

    const ownedCoins = document.createElement('div');
    ownedCoins.className = 'owned-coins';

    node.addEventListener('click', () => {
      // â˜…é¸æŠä¸­ï¼ˆåŠ¹æœ11/1/12ï¼‰ã¯åº§å¸­å¥ªå–ã‚¯ãƒªãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–
      if (isSelectingOtherHandsNow()) return;

      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `ã€Œ${p.name}ã€ã‚’è¿½ã„å‡ºã—ã¦ã€ã“ã®å¸­ã«ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ`;
      kickDialog.classList.remove('hidden');
    });

    const handData = state.hands[p.id];
    const roleCount = (handData && Array.isArray(handData.roleCards)) ? handData.roleCards.length : 0;

    if (p.id !== state.userId && roleCount > 0){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const square = document.createElement('div');
      square.className = 'mini-hand-square';
      square.classList.toggle('hidden', hasLostCrystalChip(p.id));

      const count = roleCount;
      const spread = 70;
      const base = (count > 1) ? (-spread/2) : 0;

      for (let i=0;i<count;i++){
        const c = document.createElement('div');
        c.className = 'mini-card';
        c.textContent = '';

        const angleDeg = (count > 1) ? base + (spread/(count-1))*i : 0;
        c.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
       c.style.zIndex = String(10 + i);
        miniHand.appendChild(c);
      }
      tag.appendChild(square);
      tag.appendChild(miniHand);

      // â˜…è¿½åŠ ï¼šã‚¯ãƒªãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šï¼ˆé¸æŠä¸­ã ã‘æœ‰åŠ¹ï¼‰
      const hit = document.createElement('div');
      hit.className = 'mini-hand-hit';
      hit.title = 'æ‰‹æœ­ã‚’é¸æŠ';
      hit.addEventListener('click', (e) => {
        e.stopPropagation();
        onOtherHandClicked(p.id, e);
      });
      tag.appendChild(hit);

      ui.miniHandByUserId.set(p.id, miniHand);
      ui.miniHandHitByUserId.set(p.id, hit);
      ui.miniHandSquareByUserId.set(p.id, square);
    }

    node.appendChild(owncoin);
    node.appendChild(tag);
    node.appendChild(ownedCoins);
    playerCircle.appendChild(node);

    ui.nodeByUserId.set(p.id, node);
    ui.tagByUserId.set(p.id, tag);
    ui.owncoinByUserId.set(p.id, owncoin);
  });

  renderOwnedCoinsBadges();
  updateSelectModeUI();
  updateHandmarks();
  updateMiniHandSquares();
  renderPower5Link();
}


/* =========================
   è¿½ã„å‡ºã—ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || 'åç„¡ã—' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   åŠ¹æœ7ï¼šæˆã‘ã¾ã™ã‹ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
   ========================= */
let pendingGiveTargetId = null;
let pendingGiveTargetName = null;
let pendingPower10TargetId = null;
let pendingPower10TargetName = null;

giveDialog.addEventListener('click', (e) => {
  if (e.target === giveDialog) {
    giveDialog.classList.add('hidden');
    pendingGiveTargetId = null;
    pendingGiveTargetName = null;
  }
});
btnGiveNo.addEventListener('click', (e) => {
  e.stopPropagation();
  giveDialog.classList.add('hidden');
  pendingGiveTargetId = null;
  pendingGiveTargetName = null;
});
btnGiveYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (!state.roomCode) return;
  if (!pendingGiveTargetId) {
    giveDialog.classList.add('hidden');
    return;
  }

  const p7 = state.game?.power7 || null;
  if (p7 && p7.used) {
    giveDialog.classList.add('hidden');
    pendingGiveTargetId = null;
    pendingGiveTargetName = null;
    updatePower7UI();
    return;
  }

  const targetId = pendingGiveTargetId;

  await runTransaction(ref(db, `rooms/${state.roomCode}/hands/${targetId}/roleCards`), (cur) => {
    const arr = Array.isArray(cur) ? [...cur] : [];
    arr.push("éœŠé­‚");
    return arr;
  });

  await runTransaction(ref(db, `rooms/${state.roomCode}/game/power7`), (cur) => {
    const round = Number(state.game?.round || cur?.round || 1);
    const giverId = state.game?.powerDisplay?.ownerId || cur?.giverId || null;
    if (!cur || cur.round !== round || cur.giverId !== giverId) {
      return { round, giverId, used:true, targetId, grantedAt: Date.now() };
    }
    if (cur.used) return cur;
    cur.used = true;
    cur.targetId = targetId;
    cur.grantedAt = Date.now();
    return cur;
  });

  giveDialog.classList.add('hidden');
  pendingGiveTargetId = null;
  pendingGiveTargetName = null;
  updatePower7UI();
});

/* =========================
   åŠ¹æœ10ï¼šé¸æŠ/ç¢ºèª/å¤‰æ›´
   ========================= */
power10ConfirmPop.addEventListener('click', (e) => {
  e.stopPropagation();
});
btnPower10ConfirmNo.addEventListener('click', (e) => {
  e.stopPropagation();
  hidePower10Confirm();
});
btnPower10ConfirmYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (!state.roomCode) return;
  if (!pendingPower10TargetId) return;

  const targetId = pendingPower10TargetId;
  const now = Date.now();
  const round = Number(state.game?.round || 1);

  await runTransaction(ref(db, `rooms/${state.roomCode}/game/power10`), (cur) => {
    const pd = state.game?.powerDisplay || null;
    if (!pd || pd.ownerId !== state.userId || Number(pd.number) !== 10) return cur || null;
    const c = cur || {};
    if (c.status !== 'selecting') return c;
    if (Number(c.round || 0) !== round) return c;
    return {
      ...c,
      status: 'awaiting-change',
      targetId,
      chosenAt: now
    };
  });

  hidePower10Confirm();
});

btnPower10Skip.addEventListener('click', (e) => {
  e.stopPropagation();
  power10SkipDialog.classList.remove('hidden');
});
power10SkipDialog.addEventListener('click', (e) => {
  if (e.target === power10SkipDialog) {
    power10SkipDialog.classList.add('hidden');
  }
});
btnPower10SkipNo.addEventListener('click', (e) => {
  e.stopPropagation();
  power10SkipDialog.classList.add('hidden');
});
btnPower10SkipYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (!state.roomCode) return;

  const now = Date.now();
  const round = Number(state.game?.round || 1);

  await runTransaction(ref(db, `rooms/${state.roomCode}/game/power10`), (cur) => {
    const pd = state.game?.powerDisplay || null;
    if (!pd || pd.ownerId !== state.userId || Number(pd.number) !== 10) return cur || null;
    const c = cur || {};
    if (Number(c.round || 0) !== round) return c;
    if (c.status !== 'selecting') return c;
    return {
      ...c,
      status: 'skipped',
      skippedAt: now
    };
  });

  power10SkipDialog.classList.add('hidden');
});

/* =========================
   ã‚²ãƒ¼ãƒ é–‹å§‹ï¼šé…å¸ƒ + ã‚³ã‚¤ãƒ³ç”Ÿæˆï¼ˆ1å€‹ï¼‰ + discardåˆæœŸåŒ–
   ========================= */
function buildRoleHandsForPlayers(playerIds){
  const n = playerIds.length;

  const basePatterns = [
    ["ç™½è–”è–‡","ä¿¡è€…","éœŠé­‚"],
    ["åŒåˆƒ","åŒåˆƒ","ä¿¡è€…"],
    ["å¸æ•™","ä¿¡è€…","éœŠé­‚"],
    ["æš—åˆƒ","ä¿¡è€…","éœŠé­‚"],
  ];

  let extraCount = 0;
  if (n === 7) extraCount = 1;
  if (n === 8) extraCount = 1;
  if (n === 9) extraCount = 2;
  if (n === 10) extraCount = 2;

const extraPattern = ["å·¨åˆƒ","ä¿¡è€…","éœŠé­‚"];

  const baseHand = ["ä¿¡è€…","ä¿¡è€…","éœŠé­‚"];
  const patterns = Array.from({ length: n }, () => [...baseHand]);
  for (let i=0;i<basePatterns.length && i<n;i++){
    patterns[i] = [...basePatterns[i]];
  }
  for (let k=0;k<extraCount;k++){
    const idx = basePatterns.length + k;
    if (idx < n){
      patterns[idx] = [...extraPattern];
    }
  }

  const shuffledPlayers = shuffleArray(playerIds);
  const hands = {};
  shuffledPlayers.forEach((uid, i) => {
    hands[uid] = patterns[i] ? [...patterns[i]] : [...baseHand];
  });
  return hands;
}

function shuffleArray(arr){
  const a = [...arr];
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

async function startGameDeal(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { id:t.playerId, seatIndex:Number(seatIndex) } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  const playerIds = players.map(p=>p.id);
  if (!playerIds.length) return;

  const roleHands = buildRoleHandsForPlayers(playerIds);

  const deck = shuffleArray(Array.from({length:12}, (_,i)=>i+1));
  const hands = {};
  playerIds.forEach((uid, i) => {
    hands[uid] = {
      roleCards: roleHands[uid] || ["ä¿¡è€…","ä¿¡è€…","éœŠé­‚"],
      numberCard: deck[i % deck.length]
    };
  });

  const coins = {
    coin1: {
      xPct: 0.5,
      yPct: 0.5,
      lockBy: null,
      ownerId: null,
      updatedAt: Date.now()
    }
  };

  const discard = { rose: [], blade: [], alive: [], dead: [] };

  const base = `rooms/${state.roomCode}`;

  const roleToUids = { "ç™½è–”è–‡":[], "å¸æ•™":[], "å¤§åˆƒ":[], "åŒåˆƒ":[], "æš—åˆƒ":[] };

  for (const uid of playerIds){
    const cards = (hands[uid]?.roleCards && Array.isArray(hands[uid].roleCards)) ? hands[uid].roleCards : [];

    if (cards.includes("ç™½è–”è–‡")) roleToUids["ç™½è–”è–‡"].push(uid);
    if (cards.includes("å¸æ•™"))   roleToUids["å¸æ•™"].push(uid);
    if (cards.includes("åŒåˆƒ"))   roleToUids["åŒåˆƒ"].push(uid);
    if (cards.includes("æš—åˆƒ"))   roleToUids["æš—åˆƒ"].push(uid);

    // å¤§åˆƒï¼ˆå·¨åˆƒ/å¤§åˆƒã©ã¡ã‚‰ã§ã‚‚ï¼‰
    if (cards.includes("å¤§åˆƒ") || cards.includes("å·¨åˆƒ")) roleToUids["å¤§åˆƒ"].push(uid);
  }


  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/plays`), null),
    set(ref(db, `${base}/roundPlays`), null),
    set(ref(db, `${base}/coins`), coins),
    set(ref(db, `${base}/discard`), discard),
    update(ref(db, `${base}/game`), {
      started: true,
      round: 1,

      phase: "collect",
      powerDisplay: null,
      power7: null,
      power34: null,
      power10: null,
      power5: null,
     power11: null,   // â˜…è¿½åŠ 
      power112: null,  // â˜…è¿½åŠ 
      chipLosses: {},
      lastCoinOwnerId: null,
      tableList: null,
      waitStartedAt: null,
      shuffleStartedAt: null,
      startedAt: Date.now(),
      startRoles: { roleToUids, decidedAt: Date.now() },

    })
  ]);
}

/* =========================
   æå‡ºï¼ˆplaysï¼‰æç”»ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼â†’ä¸­å¤®æ–¹å‘ã®ãƒãƒ¼ã‚«ãƒ¼
   ========================= */
function renderPlays(){
  renderPlayedMarkers();
  applyPlayableAnimToMyHand();
  updatePlayedCardAngles();

}

let resizeRaf = null;
function handleViewportResize(){
  if (resizeRaf){
    cancelAnimationFrame(resizeRaf);
  }
  resizeRaf = requestAnimationFrame(() => {
    resizeRaf = null;
    renderPlays();
    renderCoins();
  });
}
window.addEventListener('resize', handleViewportResize);

function hashToNumber(str){
  let h = 0;
  for (let i = 0; i < str.length; i++){
    h = ((h << 5) - h) + str.charCodeAt(i);
    h |= 0;
  }
  return Math.abs(h);
}

function setShuffleVars(el, uid){
  const base = hashToNumber(uid);
  const jitter = (offset, range) => {
    const v = Math.sin(base + offset) * 10000;
    return (v - Math.floor(v)) * range * 2 - range;
  };
  el.style.setProperty('--sx1', `${jitter(1, 12).toFixed(1)}px`);
  el.style.setProperty('--sy1', `${jitter(2, 10).toFixed(1)}px`);
  el.style.setProperty('--sr1', `${jitter(3, 12).toFixed(1)}deg`);
  el.style.setProperty('--sx2', `${jitter(4, 16).toFixed(1)}px`);
  el.style.setProperty('--sy2', `${jitter(5, 14).toFixed(1)}px`);
  el.style.setProperty('--sr2', `${jitter(6, 16).toFixed(1)}deg`);
  el.style.setProperty('--sx3', `${jitter(7, 10).toFixed(1)}px`);
  el.style.setProperty('--sy3', `${jitter(8, 12).toFixed(1)}px`);
  el.style.setProperty('--sr3', `${jitter(9, 10).toFixed(1)}deg`);
}

function renderPlayedMarkers(){
  const plays = state.plays || {};
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const isShuffle = started && phase === 'shuffle';
  const isReveal2 = started && phase === 'reveal2';
  const isTable = started && phase === 'table';

  for (const [uid, el] of ui.playedBackByUserId){
    if (!plays[uid] || isTable) {
      el.remove();
      ui.playedBackByUserId.delete(uid);
    }
  }
  if (isTable) return;

  const circleRect = playerCircle.getBoundingClientRect();
  const centerX = circleRect.left + circleRect.width/2;
  const centerY = circleRect.top  + circleRect.height/2;
  const discardRect = discardTable.getBoundingClientRect();
  const shuffleX = discardRect.left + discardRect.width/2;
  const shuffleY = discardRect.top + discardRect.height/2;
  const shufflePoint = clientToMainCoords(shuffleX, shuffleY);

  for (const uid of Object.keys(plays)){
    const p = plays[uid];
    if (!p) continue;

    const node = ui.nodeByUserId.get(uid);
    if (!node) continue;

    const nodeRect = node.getBoundingClientRect();
    const tagCX = nodeRect.left + nodeRect.width/2;
    const tagCY = nodeRect.top  + nodeRect.height/2;

    const t = 0.62;
    const x = centerX + (tagCX - centerX) * t;
    const y = centerY + (tagCY - centerY) * t;

    let marker = ui.playedBackByUserId.get(uid);
    const point = clientToMainCoords(x, y);


    const wantKind = (p.kind === 'pass') ? 'pass' : (isReveal2 ? 'front' : 'role');
    const haveKind = marker?.dataset?.kind || null;
    if (marker && haveKind !== wantKind){
      marker.remove();
      ui.playedBackByUserId.delete(uid);
      marker = null;
    }

    if (!marker){
      if (p.kind === 'pass'){
        marker = document.createElement('div');
        marker.className = 'played-x';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'pass';
        marker.textContent = 'âœ•';
      } else if (isReveal2){
        marker = document.createElement('div');
        marker.className = 'played-front';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'front';

        const tEl = document.createElement('div');
        tEl.className = 't';
        tEl.textContent = p.card || '';
        marker.appendChild(tEl);
      } else {
        marker = document.createElement('div');
        marker.className = 'played-back';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'role';

        const bk = document.createElement('div');
        bk.className = 'bk';
        bk.style.backgroundImage = `url('${ASSET.roleBack}')`;
        marker.appendChild(bk);
      }

     mainEl.appendChild(marker);
      ui.playedBackByUserId.set(uid, marker);
    }

    marker.style.left = `${point.x}px`;
    marker.style.top  = `${point.y}px`;

    if (isShuffle){
      setShuffleVars(marker, uid);
      marker.classList.add('shuffling');
      marker.style.left = `${shufflePoint.x}px`;
      marker.style.top  = `${shufflePoint.y}px`;
    } else {
      marker.classList.remove('shuffling');
      marker.style.left = `${point.x}px`;
      marker.style.top  = `${point.y}px`;
    }

    if (p.kind === 'pass'){
      marker.style.transform = 'translate(-50%,-50%)' + (isReveal2 ? ' scale(0.7)' : '');
    } else if (isReveal2){
      marker.style.backgroundImage = `url('${ASSET.roleFront[p.card] || ''}')`;
      marker.style.transform = `translate(-50%,-50%) scale(0.7)`;
    } else {
      marker.style.transform = isShuffle ? 'translate(-50%,-50%)' : `translate(-50%,-50%) rotate(${(p.seatIndex||0)*3}deg)`;
    }
  }
}

/* =========================
   â˜…å…¨å“¡æå‡ºå¾Œï¼š3ç§’ â†’ shuffle â†’ table
   ãŸã ã— åŠ¹æœ2 ã®å ´åˆï¼š3ç§’ â†’ reveal2ï¼ˆè¡¨ã§ãã®ä½ç½®ã«è¡¨ç¤ºã€ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚‚tableã‚‚ç„¡ã—ï¼‰
   ========================= */
let hostPhaseTimer = null;
let hostAdvanceBusy = false;

function clearHostPhaseTimer(){
  if (hostPhaseTimer){
    clearTimeout(hostPhaseTimer);
    hostPhaseTimer = null;
  }
}

function buildTableListFromPlaysShuffled(playsObj){
  const raw = Object.entries(playsObj || {})
    .map(([uid, p]) => {
      if (!p) return null;
      return {
        uid,
        kind: p.kind === 'pass' ? 'pass' : 'role',
        card: p.kind === 'pass' ? null : (p.card || null),
        seatIndex: Number(p.seatIndex ?? 0),
        playedAt: Number(p.playedAt || 0)
      };
    })
    .filter(Boolean);

  return shuffleArray(raw);
}

function buildTableListFromPlaysNoShuffle(playsObj){
  const raw = Object.entries(playsObj || {})
    .map(([uid, p]) => {
      if (!p) return null;
      return {
        uid,
        kind: p.kind === 'pass' ? 'pass' : 'role',
        card: p.kind === 'pass' ? null : (p.card || null),
        seatIndex: Number(p.seatIndex ?? 0),
        playedAt: Number(p.playedAt || 0)
      };
    })
    .filter(Boolean);

  raw.sort((a,b) => (a.seatIndex - b.seatIndex) || (a.playedAt - b.playedAt));
  return raw;
}

async function hostStepWaitToNext(){
  if (!state.isHost || !state.roomCode) return;
  if (hostAdvanceBusy) return;
  hostAdvanceBusy = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const [gameSnap, playsSnap, tablesSnap] = await Promise.all([
      get(ref(db, `${base}/game`)),
      get(ref(db, `${base}/plays`)),
      get(ref(db, `${base}/tables`)),
    ]);

    const game = gameSnap.val() || {};
    const plays = playsSnap.val() || {};
    const tables = tablesSnap.val() || {};

    if (!game.started) return;
    if ((game.phase || 'collect') !== 'wait') return;

    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? ({ id:t.playerId, seatIndex:Number(seatIndex) }) : null))
      .filter(Boolean);

    const playerCount = players.length;
    const playedCount = Object.keys(plays || {}).length;

    if (playerCount <= 0 || playedCount !== playerCount) return;

    const powerNum = Number(game?.powerDisplay?.number ?? null);

    if (powerNum === 2){
      const tableList = buildTableListFromPlaysNoShuffle(plays);
      await update(ref(db, `${base}/game`), {
        phase: 'reveal2',
        tableList,
        shuffleStartedAt: null
      });
      return;
    }

    const tableList = buildTableListFromPlaysShuffled(plays);
    await update(ref(db, `${base}/game`), {
      phase: 'shuffle',
      shuffleStartedAt: Date.now(),
      tableList
    });
  } finally {
    hostAdvanceBusy = false;
  }
}

async function hostStepShuffleToTable(){
  if (!state.isHost || !state.roomCode) return;
  if (hostAdvanceBusy) return;
  hostAdvanceBusy = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const gameSnap = await get(ref(db, `${base}/game`));
    const game = gameSnap.val() || {};
    if (!game.started) return;
    if ((game.phase || 'collect') !== 'shuffle') return;

    await update(ref(db, `${base}/game`), { phase: 'table' });
  } finally {
    hostAdvanceBusy = false;
  }
}

function maybeHostAdvanceRound(){
  if (!state.isHost || !state.game.started){
    clearHostPhaseTimer();
    return;
  }

  clearHostPhaseTimer();

  const phase = state.game.phase || 'collect';
  const players = state.players || [];
  const playerCount = players.length;
  if (playerCount <= 0) return;

  const plays = state.plays || {};
  const playedCount = Object.keys(plays).length;

  if (phase === 'collect' && playedCount === playerCount){
    const powerNum = Number(state.game?.powerDisplay?.number ?? null);
    const ownerId = state.game?.powerDisplay?.ownerId || null;

    if (powerNum === 10 && ownerId){
      const round = Number(state.game?.round || 1);
      const p10 = state.game?.power10 || null;
      if (!p10 || Number(p10.round || 0) !== round){
        update(ref(db, `rooms/${state.roomCode}/game`), {
          phase: 'power10',
          power10: {
            round,
            ownerId,
            status: 'selecting',
            targetId: null,
            changeDone: false,
            startedAt: Date.now()
          }
        });
      }
      return;
    }

    update(ref(db, `rooms/${state.roomCode}/game`), {
      phase: 'wait',
      waitStartedAt: Date.now()
    });
    return;
  }

  if (phase === 'power10'){
    const p10 = state.game?.power10 || null;
    const round = Number(state.game?.round || 0);
    const resolved = p10 && Number(p10.round || 0) === round && (p10.status === 'done' || p10.status === 'skipped');

    if (resolved){
      update(ref(db, `rooms/${state.roomCode}/game`), {
        phase: 'wait',
        waitStartedAt: Date.now()
      });
    }
    return;
  }


  if (phase === 'wait'){
    const t = Number(state.game.waitStartedAt || 0);
    const now = Date.now();
    const remain = (t ? (3000 - (now - t)) : 0);

    if (remain <= 0){
      hostStepWaitToNext();
    } else {
      hostPhaseTimer = setTimeout(() => {
        hostPhaseTimer = null;
        hostStepWaitToNext();
      }, remain + 30);
    }
    return;
  }

  if (phase === 'shuffle'){
    const t = Number(state.game.shuffleStartedAt || 0);
    const now = Date.now();
    const remain = (t ? (1000 - (now - t)) : 0);

    if (remain <= 0){
      hostStepShuffleToTable();
    } else {
      hostPhaseTimer = setTimeout(() => {
        hostPhaseTimer = null;
        hostStepShuffleToTable();
      }, remain + 20);
    }
    return;
  }
}

/* =========================
   â˜…ä¸­å¤®ã«ä¸¦ã¹ã‚‹ï¼ˆtableListï¼‰ â€»phase=tableã®ã¿
   ========================= */
function renderTableCards(){
  const started = !!state.game.started;
  const phase = state.game.phase || 'collect';
  const list = Array.isArray(state.game.tableList) ? state.game.tableList : [];

  tableGrid.innerHTML = '';
  if (!started || phase !== 'table') return;

  list.forEach(item => {
    const el = document.createElement('div');
    const isPass = (item.kind === 'pass');
    el.className = 'table-card' + (isPass ? ' pass' : '');
    if (isPass){
      el.textContent = 'âœ•';
    } else {
      el.textContent = '';
      el.style.backgroundImage = `url('${ASSET.roleFront[item.card] || ''}')`;
    }
    tableGrid.appendChild(el);
  });
}

/* =========================
   â˜… discardtableï¼ˆç©ã¿ä¸Šã’è¡¨ç¤ºï¼‰
   ========================= */
function ensureArray(v){ return Array.isArray(v) ? v : []; }

function renderStackInto(slotEl, items, mode){
  slotEl.innerHTML = '';
  const arr = ensureArray(items);
  arr.forEach((it, idx) => {
    const card = document.createElement('div');
    const isPass = (it.kind === 'pass');
    card.className = 'stack-card' + (isPass ? ' pass' : '') + (it.dead ? ' dead' : '');
    if (isPass){
      card.textContent = 'âœ•';
    } else {
      card.textContent = it.card || '';
      card.style.backgroundImage = `url('${ASSET.roleFront[it.card] || ''}')`;
    }

    const step = 7;
    let dy = 0;
    if (mode === 'down') dy = step * idx;
    if (mode === 'up') dy = -step * idx;

    card.style.transform = `translate(-50%,-50%) translateY(${dy}px)`;
    card.style.zIndex = String(10 + idx);
    slotEl.appendChild(card);
  });
}

function renderDiscardTable(){
  const d = state.discard || {};
  renderStackInto(slotRose,  d.rose,  'down');
  renderStackInto(slotBlade, d.blade, 'up');
  renderStackInto(slotAlive, d.alive, 'down');
  renderStackInto(slotDead,  d.dead,  'down');
}

/* =========================
   â˜…ãƒ›ã‚¹ãƒˆï¼šæ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰
   ========================= */
btnNextRound.addEventListener('click', async () => {
  if (!state.isHost) return;
  if (!state.roomCode) return;
  const phase = state.game.phase || 'collect';
  if (phase !== 'table' && phase !== 'reveal2') return;

  const base = `rooms/${state.roomCode}`;
  const gameSnap = await get(ref(db, `${base}/game`));
  const game = gameSnap.val() || {};
  const list = Array.isArray(game.tableList) ? game.tableList : [];
  const round = Number(game.round || 1);
  const isRevealRound = (phase === 'reveal2');

  const coinSnap = await get(ref(db, `${base}/coins/${COIN_ID}`));
  const coin = coinSnap.val() || {};
  const endOwnerId = coin.ownerId || null;
  const chipLosses = { ...(game.chipLosses || {}) };
  if (endOwnerId) chipLosses[endOwnerId] = true;

  const bladePlayed = list.some(it => it && it.kind === 'role' && BLADE_SET.has(it.card));

  const toRose = [];
  const toBlade = [];
  const toAlive = [];
  const toDead = [];

  for (const it of list){
    if (!it) continue;
    if (it.kind !== 'role') continue;

    const card = it.card;
    if (!card) continue;

    if (card === 'éœŠé­‚') continue;
    if (BLADE_SET.has(card)){
      toBlade.push({ kind:'role', card, round, addedAt: Date.now() });
      continue;
    }

    if (card === 'ç™½è–”è–‡'){
      const dead = !!bladePlayed;
      toRose.push({ kind:'role', card, dead, round, addedAt: Date.now() });
      continue;
    }

   if (card === 'å¸æ•™' || card === 'ä¿¡è€…'){
      const dead = !!bladePlayed;
      if (dead) toDead.push({ kind:'role', card, round, addedAt: Date.now() });
      else toAlive.push({ kind:'role', card, round, addedAt: Date.now() });
      continue;
    }
  }

  const roundPlays = {};
  for (const it of list){
    if (!it || !it.uid) continue;
    if (it.kind === 'pass'){
      roundPlays[it.uid] = { kind: 'pass', recordedAt: Date.now() };
      continue;
    }
    if (it.kind === 'role'){
      const entry = { kind: 'role', recordedAt: Date.now() };
      if (isRevealRound && it.card){
        entry.card = it.card;
        entry.revealed = true;
      }
      roundPlays[it.uid] = entry;
    }
  }

  const dRef = ref(db, `${base}/discard`);
  await runTransaction(dRef, (cur) => {
    const d = cur || {};
    d.rose  = ensureArray(d.rose);
    d.blade = ensureArray(d.blade);
    d.alive = ensureArray(d.alive);
    d.dead  = ensureArray(d.dead);

    d.rose.push(...toRose);
    d.blade.push(...toBlade);
    d.alive.push(...toAlive);
    d.dead.push(...toDead);
    return d;
  });

  await Promise.all([
   set(ref(db, `${base}/plays`), null),
    set(ref(db, `${base}/roundPlays/${round}`), roundPlays),
    update(ref(db, `${base}/game`), {
      round: round + 1,
      phase: 'collect',
      powerDisplay: null,
      power7: null,
      power34: null,
      power10: null,
      power5: null,
      power11: null,   // â˜…è¿½åŠ 
      power112: null,  // â˜…è¿½åŠ 
      chipLosses,
      lastCoinOwnerId: endOwnerId,
      tableList: null,
      waitStartedAt: null,
      shuffleStartedAt: null
    })
  ]);
});

/* =========================
   æå‡ºï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ï¼‰/ å‡ºã•ãªã„ï¼ˆã‚¯ãƒªãƒƒã‚¯ï¼‰
   ========================= */
let drag = null;

function startDragCard(e, payload){
  if (!state.game.started) return;
  if (isCoinOwnerChangeRequired()) return;

  const phase = state.game.phase || 'collect';
  const power10Allowed = isPower10ChangeAllowed();
  if (phase !== 'collect' && !power10Allowed) return;
  if (!power10Allowed && isEveryoneDecided()) return;
  if (payload.kind !== 'role') return;

  // â˜…åŠ¹æœ3/4ã§é¸ã¹ãªã„äººã¯ãƒ‰ãƒ©ãƒƒã‚°ä¸å¯
  if (!power10Allowed && isMyPlayLockedByPower34()) return;
  // â˜…åŠ¹æœ5ï¼š2äººæ±ºå®šå‰ã¯å…¨å“¡é¸æŠä¸å¯
  if (!power10Allowed && isPower5SelectionIncomplete()) return;
  // â˜…åŠ¹æœ5ï¼šå…ˆã®äººãŒæ±ºã‚ã‚‹ã¾ã§å¾Œã®äººã¯ãƒ‰ãƒ©ãƒƒã‚°ä¸å¯
  if (!power10Allowed && isMyPlayLockedByPower5Waiting()) return;
  // â˜…åŠ¹æœ5ã§å…ˆãŒâœ•ã®æ™‚ã€å¾Œã®äººã¯é¸æŠä¸å¯
  if (!power10Allowed && isMyPlayLockedByPower5Pass()) return;


  const target = e.currentTarget;
  if (!(target instanceof HTMLElement)) return;

  e.preventDefault();
  target.setPointerCapture?.(e.pointerId);

  target.classList.add('dragging');

  const ghost = target.cloneNode(true);
  ghost.classList.add('drag-ghost');
  mainEl.appendChild(ghost);

  drag = {
    ghost,
    kind: payload.kind,
    cardName: payload.cardName,
    pointerId: e.pointerId,
    srcEl: target
  };

  moveGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!drag || ev.pointerId !== drag.pointerId) return;
    moveGhost(ev.clientX, ev.clientY);
  };
  const onUp = async (ev) => {
    if (!drag || ev.pointerId !== drag.pointerId) return;

    const dropped = isOverDiscardTable(ev.clientX, ev.clientY);

    drag.srcEl?.classList.remove('dragging');

    drag.ghost.remove();
    drag = null;

    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    if (!dropped) return;
    await setMyPlay({ kind:'role', cardName: payload.cardName });
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

function moveGhost(x, y){
  if (!drag) return;
  const point = clientToMainCoords(x, y);
  drag.ghost.style.left = `${point.x}px`;
  drag.ghost.style.top  = `${point.y}px`;
}

function isOverDiscardTable(x, y){
  const r = discardTable.getBoundingClientRect();
  return (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom);
}


let isSettingMyPlay = false;
async function setMyPlay({ kind, cardName=null }){
  if (!state.roomCode) return;
  if (!state.game.started) return;


  const phase = state.game.phase || 'collect';
  const power10Allowed = isPower10ChangeAllowed();
  if (phase !== 'collect' && !power10Allowed) return;
  if (!power10Allowed && isEveryoneDecided()) return;

  // â˜…åŠ¹æœ3/4ã§é¸ã¹ãªã„äººã¯ã€Œå‡ºã•ãªã„ã€ã‚‚ä¸å¯
  if (!power10Allowed && isMyPlayLockedByPower34()) return;
  // â˜…åŠ¹æœ5ï¼š2äººæ±ºå®šå‰ã¯å…¨å“¡é¸æŠä¸å¯
  if (!power10Allowed && isPower5SelectionIncomplete()) return;
  // â˜…åŠ¹æœ5ï¼šå…ˆã®äººãŒæ±ºã‚ã‚‹ã¾ã§å¾Œã®äººã¯ä¸å¯
  if (!power10Allowed && isMyPlayLockedByPower5Waiting()) return;
  // â˜…åŠ¹æœ5ï¼šå…ˆã®äººãŒâœ•ãªã‚‰å¾Œã®äººã¯ã‚«ãƒ¼ãƒ‰ä¸å¯ï¼ˆâœ•ã®ã¿è¨±å¯ï¼‰
  if (!power10Allowed && isMyPlayLockedByPower5Pass() && kind !== 'pass') return;
  if (power10Allowed && kind !== 'role') return;

  const uid = state.userId;
  const old = state.plays?.[uid] || null;


  const roleRef = ref(db, `rooms/${state.roomCode}/hands/${uid}/roleCards`);
  const newIsRole = (kind === 'role');
  const oldIsRole = (old && old.kind === 'role' && old.card);

  isSettingMyPlay = true;
  try {
    const tx = await runTransaction(roleRef, (current) => {
      let arr = Array.isArray(current) ? [...current] : [];
      if (oldIsRole && !arr.includes(old.card)) arr.push(old.card);
      if (newIsRole){
        const idx = arr.indexOf(cardName);
        if (idx === -1) return;

        arr.splice(idx, 1);
      }
      return arr;
    });

    if (!tx.committed) return;

    const seatIndex = state.seatedTable || 0;
    await set(ref(db, `rooms/${state.roomCode}/plays/${uid}`), {
      kind: newIsRole ? 'role' : 'pass',
      card: newIsRole ? cardName : null,
      seatIndex,
      playedAt: Date.now()
    });

    if (power10Allowed){
      await runTransaction(ref(db, `rooms/${state.roomCode}/game/power10`), (cur) => {
        const c = cur || {};
        if (c.status !== 'awaiting-change') return c;
        if (c.targetId !== uid) return c;
        if (c.changeDone) return c;
        return {
          ...c,
          status: 'done',
          changeDone: true,
          changedAt: Date.now()
        };
      });
    }
  } finally {
    isSettingMyPlay = false;
  }
}


/* =========================
   â˜…ã‚³ã‚¤ãƒ³ï¼šã„ã¤ã§ã‚‚ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ï¼ˆæ—¢å­˜ä»•æ§˜ï¼‰
   ========================= */
const COIN_ID = 'coin1';
const COIN_SIZE = 22;
const COIN_PAD = 6;

let coinDrag = null;

function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function rectContainsPoint(rect, x, y){
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function pctFromClientXY(clientX, clientY){
  const rect = coinPoolInner.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const usableW = Math.max(1, w - COIN_SIZE - COIN_PAD*2);
  const usableH = Math.max(1, h - COIN_SIZE - COIN_PAD*2);

  let left = (clientX - rect.left) - COIN_SIZE/2;
  let top  = (clientY - rect.top)  - COIN_SIZE/2;

  left = clamp(left, COIN_PAD, COIN_PAD + usableW);
  top  = clamp(top,  COIN_PAD, COIN_PAD + usableH);

  const xPct = (left - COIN_PAD) / usableW;
  const yPct = (top  - COIN_PAD) / usableH;

  return { xPct, yPct };
}

function placeCoinByPct(el, xPct, yPct){
  const w = coinPoolInner.clientWidth;
  const h = coinPoolInner.clientHeight;

  const usableW = Math.max(1, w - COIN_SIZE - COIN_PAD*2);
  const usableH = Math.max(1, h - COIN_SIZE - COIN_PAD*2);

  const left = COIN_PAD + usableW * clamp(Number(xPct ?? 0.5), 0, 1);
  const top  = COIN_PAD + usableH * clamp(Number(yPct ?? 0.5), 0, 1);

  el.style.left = `${left}px`;
  el.style.top  = `${top}px`;
}

function ensurePoolCoinEl(){
  if (ui.coinEl) return ui.coinEl;

  const el = document.createElement('div');
  el.className = 'coin';
  el.dataset.coinId = COIN_ID;
  el.textContent = 'â—';

  el.addEventListener('pointerdown', (e) => startDragCoinFromPool(e));
  coinPoolInner.appendChild(el);

  ui.coinEl = el;
  return el;
}

function getOwncoinHitUserId(clientX, clientY){
  for (const [uid, own] of ui.owncoinByUserId){
    const r = own.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top  + r.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    const rad = r.width/2;
    if ((dx*dx + dy*dy) <= (rad*rad)) return uid;
  }
  return null;
}
function canTransferCoinTo(targetUid, prevOwnerId){
  if (!targetUid) return true;
  if (!hasLostCrystalChip(targetUid)) return true;
  return prevOwnerId === targetUid;
}


function moveCoinGhost(x, y){
  const g = coinDrag?.ghost;
  if (!g) return;
  const point = clientToMainCoords(x, y);
  g.style.left = `${point.x}px`;
  g.style.top  = `${point.y}px`;
}

async function ensurePower7StateIfNeeded(ownerId, number){
  if (!state.roomCode) return;
  if (Number(number) !== 7) return;

  const base = `rooms/${state.roomCode}`;
  const round = Number(state.game?.round || 1);

  await runTransaction(ref(db, `${base}/game/power7`), (cur) => {
    if (cur && cur.round === round && cur.giverId === ownerId && !cur.used) return cur;
    if (cur && cur.round === round && cur.used) return cur;
    return { round, giverId: ownerId, used:false, targetId:null, createdAt: Date.now() };
  });
}

async function setPowerDisplayForOwner(ownerId){
  if (!state.roomCode || !ownerId) return;
  const numSnap = await get(ref(db, `rooms/${state.roomCode}/hands/${ownerId}/numberCard`));
  const number = numSnap.val();
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    powerDisplay: {
      ownerId,
      number: Number(number ?? null),
      shownAt: Date.now()
    }
  });

  await ensurePower7StateIfNeeded(ownerId, Number(number ?? null));

  applyPlayableAnimToMyHand();
  updateSelectModeUI();
  renderPower11Arrow();
}

function renderCoins(){
  if (!state.game.started){
    if (ui.coinEl){
      ui.coinEl.remove();
      ui.coinEl = null;
    }
    return;
  }

  const c = state.coins?.[COIN_ID] || null;

  if (c?.ownerId){
    if (ui.coinEl){
      ui.coinEl.remove();
      ui.coinEl = null;
    }
    return;
  }

  const el = ensurePoolCoinEl();
  const locked = !!(c?.lockBy && c.lockBy !== state.userId);
  el.classList.toggle('locked', locked);

  const xPct = (c && c.xPct != null) ? c.xPct : 0.5;
  const yPct = (c && c.yPct != null) ? c.yPct : 0.5;
  placeCoinByPct(el, xPct, yPct);
}

function renderOwnedCoinsBadges(){
  for (const [uid, node] of ui.nodeByUserId){
    const owned = node.querySelector('.owned-coins');
    if (owned) owned.innerHTML = '';
  }
  ui.ownedCoinDotByOwnerId.clear();

  for (const coinId of Object.keys(state.coins || {})){
    const c = state.coins[coinId];
    if (!c || !c.ownerId) continue;

    const node = ui.nodeByUserId.get(c.ownerId);
    if (!node) continue;
    const owned = node.querySelector('.owned-coins');
    if (!owned) continue;

    const dot = document.createElement('div');
    dot.className = 'owned-coin-dot';
    dot.textContent = 'â—';
    dot.dataset.coinId = coinId;
    dot.dataset.ownerId = c.ownerId;

    const locked = !!(c.lockBy && c.lockBy !== state.userId);
    dot.classList.toggle('locked', locked);

    dot.addEventListener('pointerdown', (e) => startDragCoinFromOwned(e, coinId, c.ownerId));

    owned.appendChild(dot);
    ui.ownedCoinDotByOwnerId.set(c.ownerId, dot);
  }
}

function startDragCoinFromPool(e){
  if (!state.roomCode) return;
  if (!state.game.started) return;

  const c = state.coins?.[COIN_ID];
  if (c?.ownerId) return;
  if (c?.lockBy && c.lockBy !== state.userId) return;

  e.preventDefault();

  const realEl = ensurePoolCoinEl();
  const pointerId = e.pointerId;
  realEl.setPointerCapture?.(pointerId);

  const ghost = realEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  mainEl.appendChild(ghost);

  realEl.style.opacity = '0.25';

  const prevState = {
    ownerId: c?.ownerId ?? null,
    xPct: c?.xPct ?? 0.5,
    yPct: c?.yPct ?? 0.5
  };

  coinDrag = {
    pointerId,
    ghost,
    source:'pool',
    sourceOwnerId:null,
    raf:null,
    lastClientX:e.clientX,
    lastClientY:e.clientY,
    prevState
  };


  const { xPct, yPct } = pctFromClientXY(e.clientX, e.clientY);
  update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
    xPct, yPct,
    lockBy: state.userId,
    updatedAt: Date.now()
  });

  moveCoinGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    coinDrag.lastClientX = ev.clientX;
    coinDrag.lastClientY = ev.clientY;

    moveCoinGhost(ev.clientX, ev.clientY);

    const poolRect = coinPoolInner.getBoundingClientRect();
    const inPool = rectContainsPoint(poolRect, ev.clientX, ev.clientY);
    if (!inPool) return;

    if (coinDrag.raf) return;
    coinDrag.raf = requestAnimationFrame(() => {
      coinDrag.raf = null;
      const { xPct, yPct } = pctFromClientXY(coinDrag.lastClientX, coinDrag.lastClientY);
      update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        xPct, yPct,
        lockBy: state.userId,
        updatedAt: Date.now()
      });
    });
  };

  const onUp = async (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    const prev = coinDrag?.prevState || null;
    coinDrag.ghost.remove();
    coinDrag = null;
    realEl.style.opacity = '';

    const poolRect = coinPoolInner.getBoundingClientRect();
    const inPool = rectContainsPoint(poolRect, ev.clientX, ev.clientY);

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);

    if (hitUid){
      if (!canTransferCoinTo(hitUid, prev?.ownerId ?? null)){
        showCoinWarningPop();
        await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
          ownerId: prev?.ownerId ?? null,
          xPct: prev?.xPct ?? 0.5,
          yPct: prev?.yPct ?? 0.5,
          lockBy: null,
          updatedAt: Date.now()
        });
        return;
      }
      await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        ownerId: hitUid,
        lockBy: null,
        updatedAt: Date.now()
      });
      await setPowerDisplayForOwner(hitUid);
      await maybeClearCoinOwnerChangeLock(hitUid);
      return;
    }

    if (inPool){
      const { xPct, yPct } = pctFromClientXY(ev.clientX, ev.clientY);
      await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        xPct, yPct,
        lockBy: null,
        updatedAt: Date.now()
      });
      await maybeClearCoinOwnerChangeLock(null);
      return;
    }

    await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
      lockBy: null,
      updatedAt: Date.now()
    });
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

function startDragCoinFromOwned(e, coinId, currentOwnerId){
  if (!state.roomCode) return;
  if (!state.game.started) return;

  const c = state.coins?.[coinId];
  if (!c) return;
  if (c.lockBy && c.lockBy !== state.userId) return;

  e.preventDefault();

  const srcEl = e.currentTarget;
  if (!(srcEl instanceof HTMLElement)) return;

  const pointerId = e.pointerId;
  srcEl.setPointerCapture?.(pointerId);

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  mainEl.appendChild(ghost);
  srcEl.style.opacity = '0.25';

  const prevState = {
    ownerId: c?.ownerId ?? currentOwnerId ?? null,
    xPct: c?.xPct ?? 0.5,
    yPct: c?.yPct ?? 0.5
  };

  coinDrag = {
    pointerId,
    ghost,
    source:'owned',
    sourceOwnerId:currentOwnerId,
    raf:null,
    lastClientX:e.clientX,
    lastClientY:e.clientY,
    prevState
  };

  update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
    lockBy: state.userId,
    updatedAt: Date.now()
  });

  moveCoinGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    coinDrag.lastClientX = ev.clientX;
    coinDrag.lastClientY = ev.clientY;
    moveCoinGhost(ev.clientX, ev.clientY);
  };

  const onUp = async (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    const prev = coinDrag?.prevState || null;
    coinDrag.ghost.remove();
    coinDrag = null;
    srcEl.style.opacity = ''

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);

    if (hitUid){
      if (!canTransferCoinTo(hitUid, prev?.ownerId ?? null)){
        showCoinWarningPop();
        await update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
          ownerId: prev?.ownerId ?? null,
          xPct: prev?.xPct ?? 0.5,
          yPct: prev?.yPct ?? 0.5,
          lockBy: null,
          updatedAt: Date.now()
        });
        return;
      }
      await update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
        ownerId: hitUid,
        lockBy: null,
        updatedAt: Date.now()
      });
      await setPowerDisplayForOwner(hitUid);
      await maybeClearCoinOwnerChangeLock(hitUid);
      return;
    }

    await update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
      ownerId: null,
      lockBy: null,
      updatedAt: Date.now()
    });
    await maybeClearCoinOwnerChangeLock(null);
  };


  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

/* =========================
   â˜…åŠ¹æœ7ï¼šéœŠé­‚ã‚«ãƒ¼ãƒ‰UIï¼ˆã‚³ã‚¤ãƒ³ownãŒ7ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã ã‘ï¼‰
   ========================= */
function updatePower7UI(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  const p7 = state.game?.power7 || null;

  const shouldShow =
    started &&
    phase === 'collect' &&
    !!pd &&
    Number(pd.number) === 7 &&
    pd.ownerId === state.userId &&
    !(p7 && p7.used);

  spiritOverlay.classList.toggle('hidden', !shouldShow);

  if (shouldShow){
    spiritCard.style.backgroundImage = `url('${ASSET.roleFront["éœŠé­‚"] || ''}')`;
    spiritCard.textContent = '';
  } else {
    spiritCard.textContent = 'éœŠé­‚';
  }
}

let spiritDrag = null;

function moveSpiritGhost(x, y){
  const g = spiritDrag?.ghost;
  if (!g) return;
  const point = clientToMainCoords(x, y);
  g.style.left = `${point.x}px`;
  g.style.top  = `${point.y}px`;
}
function startDragSpirit(e){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  const p7 = state.game?.power7 || null;

  if (!started) return;
  if (phase !== 'collect') return;
  if (!pd || Number(pd.number) !== 7) return;
  if (pd.ownerId !== state.userId) return;
  if (p7 && p7.used) return;

  e.preventDefault();
  const pointerId = e.pointerId;
  spiritCard.setPointerCapture?.(pointerId);

  const ghost = spiritCard.cloneNode(true);
  ghost.classList.add('drag-ghost');
  mainEl.appendChild(ghost);

  spiritCard.style.opacity = '0.25';
  spiritDrag = { pointerId, ghost };

  moveSpiritGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!spiritDrag || ev.pointerId !== spiritDrag.pointerId) return;
    moveSpiritGhost(ev.clientX, ev.clientY);
  };

  const onUp = (ev) => {
    if (!spiritDrag || ev.pointerId !== spiritDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    spiritDrag.ghost.remove();
    spiritDrag = null;
    spiritCard.style.opacity = '';

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);
    if (!hitUid) return;

    const targetName = (state.players || []).find(p => p.id === hitUid)?.name || 'èª°ã‹';
    pendingGiveTargetId = hitUid;
    pendingGiveTargetName = targetName;
    giveMessage.textContent = `ã€Œ${targetName}ã€ã«æˆã‘ã¾ã™ã‹ï¼Ÿ`;
    giveDialog.classList.remove('hidden');
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

spiritCard.addEventListener('pointerdown', startDragSpirit);

/* =========================
   ãƒ›ã‚¹ãƒˆè¨­å®šUIï¼ˆæ—¢å­˜ï¼‰
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDeal();
  startPop.classList.add('hidden');
});

/* â˜…ãƒªã‚»ãƒƒãƒˆï¼šäººæ•°é¸æŠã¸æˆ»ã™ï¼ˆæœ€å°å®Ÿè£…ï¼‰ */
btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  await Promise.all([
    update(ref(db, `${base}`), { maxPlayers: null }),
    set(ref(db, `${base}/tables`), null),
    set(ref(db, `${base}/hands`), null),
    set(ref(db, `${base}/plays`), null),
    set(ref(db, `${base}/roundPlays`), null),
    set(ref(db, `${base}/coins`), null),
    set(ref(db, `${base}/discard`), null),
    update(ref(db, `${base}/game`), {
      started:false,
      round: 0,
      phase: "collect",
      powerDisplay: null,
      power7: null,
      power34: null,
      power10: null,
      power5: null,
      power11: null,
      power112: null,
      chipLosses: null,
      lastCoinOwnerId: null,
      tableList: null,
      waitStartedAt: null,
      shuffleStartedAt: null
    })
  ]);

  startPop.classList.add('hidden');
  state.seatedTable = null;
  syncSeatUI();
});

/* =========================
   åˆæœŸï¼šçŸ¢å°SVGã‚µã‚¤ã‚º
   ========================= */
ensureArrowSvgSize();
</script>
</body>
</html>
