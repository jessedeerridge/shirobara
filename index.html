<!DOCTYPE html> 
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★ 上部：コイン所有表示（公開（table/reveal2）まで表示） */
  .power-banner{
    position:fixed;
    left:50%;
    top:60px;
    transform:translateX(-50%);
    width:min(640px, calc(100% - 24px));
    background:rgba(20,20,20,.92);
    color:#fff;
    border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:10px 12px;
    z-index:405;
    display:flex;
    gap:12px;
    align-items:flex-start;
  }
  .power-banner.hidden{display:none;}
  .power-banner-num{
    width:42px;height:42px;border-radius:12px;
    display:grid;place-items:center;
    border:1px solid rgba(255,255,255,.18);
    font-weight:1000;
    font-size:22px;
    flex:0 0 auto;
    background:rgba(255,255,255,.08);
  }
  .power-banner-body{flex:1 1 auto;min-width:0;}
  .power-banner-title{
    font-weight:1000;
    font-size:13px;
    opacity:.9;
    margin-bottom:2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .power-banner-text{
    font-weight:900;
    font-size:13px;
    line-height:1.35;
    white-space:pre-wrap;
    word-break:break-word;
  }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  /* ★ プレイヤー円配置用 */
  .player-circle{
    position:relative;
    width:320px;height:320px;
    margin:18px auto 0;
    border-radius:50%;
    box-sizing:border-box;
    border:none;
  }

  /* ===== プレイヤーノード（owncoin + name + owned coins） ===== */
  .player-node{
    position:absolute;
    transform:translate(-50%,-50%);
    width:76px; height:56px;
    display:grid;
    place-items:center;
    user-select:none;
  }
  .owncoin{
    position:absolute;
    width:54px;height:54px;border-radius:50%;
    border:2px solid rgba(17,17,17,.55);
    background:rgba(255,255,255,.25);
    box-shadow:0 6px 16px rgba(0,0,0,.08);
  }

  .player-tag{
    position:relative;
    padding:4px 10px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:2;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* 所有コイン表示（タグ右側・タグ内ではない） */
  .owned-coins{
    position:absolute;
    left:calc(50% + 34px);
    top:50%;
    transform:translateY(-50%);
    display:flex; gap:4px; align-items:center;
    z-index:2;
    pointer-events:auto;
  }
  .owned-coin-dot{
    width:22px;height:22px;border-radius:50%;
    border:1px solid rgba(0,0,0,.35);
    background:linear-gradient(180deg,#fff,#eee);
    box-shadow:0 8px 16px rgba(0,0,0,.22);
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:12px;
    color:#111;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .owned-coin-dot:active{cursor:grabbing;}
  .owned-coin-dot.locked{opacity:.6; cursor:not-allowed; pointer-events:none;}

  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:66px;height:34px;pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* ===== 中央エリア（discardtable / shuffle / table並べ） ===== */
  .center-area{
    position:absolute;
    inset:0;
    pointer-events:none;
    z-index:5;
  }

  /* ★ discardtable：中央に2x2の点線四角（場カード=60x90と同じ） */
  :root{
    --field-w: 60px;
    --field-h: 90px;
    --slot-gap: 10px;
    --stack-step: 7px;
  }
  .discard-table{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:calc(var(--field-w) * 2 + var(--slot-gap));
    height:calc(var(--field-h) * 2 + var(--slot-gap));
    display:grid;
    grid-template-columns:repeat(2, var(--field-w));
    grid-template-rows:repeat(2, var(--field-h));
    gap:var(--slot-gap);
    pointer-events:none;
  }
  .discard-slot{
    position:relative;
    border:2px dashed rgba(120,120,120,.7);
    border-radius:12px;
    background:rgba(255,255,255,.48);
    box-shadow:0 10px 22px rgba(0,0,0,.06);
    overflow:visible;
  }
  .slot-label{
    position:absolute;
    left:8px; top:7px;
    font-size:10px;
    font-weight:1000;
    opacity:.62;
    letter-spacing:.06em;
    user-select:none;
    pointer-events:none;
  }
  .slot-stack{
    position:absolute;
    inset:0;
    pointer-events:none;
  }

  /* discardに積まれるカード（場カードサイズ） */
  .stack-card{
    position:absolute;
    left:50%; top:50%;
    width:var(--field-w);
    height:var(--field-h);
    transform:translate(-50%,-50%);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 10px 20px rgba(0,0,0,.16);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:1000;
    text-align:center;
    padding:4px;
    line-height:1.1;
    box-sizing:border-box;
    background-size:cover;
    background-position:center;
  }
  .stack-card.dead{
    box-shadow:0 10px 20px rgba(0,0,0,.16), 0 0 0 3px rgba(185,28,28,.22) inset;
  }
  .stack-card.pass{
    border:none;
    box-shadow:none;
    background:transparent;
    font-size:26px;
    color:#b91c1c;
    font-weight:1000;
  }

  .shuffle-card{
    position:absolute;
    left:50%; top:50%;
    width:52px;height:78px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:
      linear-gradient(135deg, rgba(0,0,0,.06), rgba(0,0,0,.14)),
      repeating-linear-gradient(45deg, rgba(0,0,0,.05) 0 5px, rgba(255,255,255,.05) 5px 10px);
    box-shadow:0 12px 24px rgba(0,0,0,.22);
    transform:translate(-50%,-50%);
    opacity:.98;
  }

  /* ★ 公開後：中央にカードを並べる（table） */
  .table-area{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:min(320px, calc(100% - 40px));
    display:none;
  }
  .table-area.show{display:block;}
  .table-grid{
    display:grid;
    grid-template-columns:repeat(4, var(--field-w));
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .table-card{
    width:var(--field-w);
    height:var(--field-h);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 12px 24px rgba(0,0,0,.20);
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    font-weight:1000;
    text-align:center;
    padding:4px;
    line-height:1.1;
    box-sizing:border-box;
    background-size:cover;
    background-position:center;
  }
  .table-card.pass{
    border:none;
    box-shadow:none;
    background:transparent;
    font-size:30px;
    color:#b91c1c;
  }

  /* 提出した裏面ミニカード（プレイヤー→中央方向に表示） */
  .played-back{
    position:absolute;
    width:22px;height:30px;
    border-radius:6px;
    border:1px solid rgba(0,0,0,.25);
    background:
      linear-gradient(135deg, rgba(0,0,0,.06), rgba(0,0,0,.14)),
      repeating-linear-gradient(45deg, rgba(0,0,0,.05) 0 5px, rgba(255,255,255,.05) 5px 10px);
    box-shadow:0 8px 18px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .played-back,
  .played-x{
    transition: left 0.45s ease, top 0.45s ease, transform 0.45s ease;
    will-change: left, top, transform;
  }
  .played-back.shuffling,
  .played-x.shuffling{
    animation: miniShuffle 1s ease-in-out both;
  }
  @keyframes miniShuffle{
    0%{
      transform:translate(-50%,-50%) rotate(0deg);
    }
    25%{
      transform:translate(calc(-50% + var(--sx1)), calc(-50% + var(--sy1))) rotate(var(--sr1));
    }
    55%{
      transform:translate(calc(-50% + var(--sx2)), calc(-50% + var(--sy2))) rotate(var(--sr2));
    }
    80%{
      transform:translate(calc(-50% + var(--sx3)), calc(-50% + var(--sy3))) rotate(var(--sr3));
    }
    100%{
      transform:translate(-50%,-50%) rotate(0deg);
    }
  }

  .played-back .bk{
    position:absolute; inset:0;
    border-radius:6px;
    background-size:cover;
    background-position:center;
    opacity:.0;
  }

  /* ★ 出さない提出：✕単体 */
  .played-x{
    position:absolute;
    width:30px;height:30px;
    display:grid;
    place-items:center;
    font-weight:1000;
    font-size:26px;
    line-height:1;
    color:#b91c1c;
    background:transparent;
    border:none;
    box-shadow:none;
    pointer-events:none;
    text-shadow:0 6px 14px rgba(0,0,0,.12);
  }

  /* ★効果2：提出位置で表にする（1.3倍） */
  .played-front{
    position:absolute;
    width:var(--field-w);
    height:var(--field-h);
    border-radius:12px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 14px 30px rgba(0,0,0,.22);
    pointer-events:none;
    background-size:cover;
    background-position:center;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    box-sizing:border-box;
    padding:6px 6px 6px;
  }
  .played-front .t{
    font-size:11px;
    font-weight:1000;
    line-height:1.1;
    color:#111;
    text-shadow:0 1px 0 rgba(255,255,255,.6);
    background:rgba(255,255,255,.72);
    border:1px solid rgba(0,0,0,.12);
    border-radius:999px;
    padding:2px 6px;
  }

  /* ===== 自分の手札表示（正体カード） ===== */
  .my-hand-wrapper{margin-top:16px;text-align:center;}
  .my-hand-title{display:none;}
  .my-hand{
    display:flex;
    justify-content:center;
    gap:8px;
    margin-top:6px;
    min-height:120px;
    align-items:flex-start;
  }

  /* 正体カード（60x90） */
  .role-card{
    width:60px;height:90px;border-radius:10px;border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.16);
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    cursor:grab;
    user-select:none;
    touch-action:none;
  }
  .role-card:active{cursor:grabbing;}
  .role-card .face{
    position:absolute; inset:0;
    border-radius:10px;
    background-size:cover;
    background-position:center;
    opacity:0;
  }
  .role-card .label{
    position:relative;
    padding:6px 6px;
    font-size:13px;
    line-height:1.1;
  }

  /* =========================
     ★追加：プレイ可能な手札カードの大小アニメ
     ========================= */
  .role-card.playable{
    animation: playablePulse 0.95s ease-in-out infinite;
    will-change: transform;
  }
  @keyframes playablePulse{
    0%   { transform: scale(1); }
    50%  { transform: scale(1.07); }
    100% { transform: scale(1); }
  }
  /* ★追加：ドラッグ中はアニメ停止 */
  .role-card.playable.dragging{
    animation: none !important;
  }

  /* “出さない”カード（同サイズ・点線グレー枠） */
  .pass-card{
    width:60px;height:90px;border-radius:10px;
    border:2px dashed rgba(140,140,140,.9);
    background:rgba(255,255,255,.6);
    box-shadow:0 10px 24px rgba(0,0,0,.10);
    position:relative;
    display:flex;align-items:center;justify-content:center;
    font-weight:900;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
    color:#555;
  }
  .pass-card .label{
    font-size:13px;
    line-height:1.1;
    padding:0 6px;
  }
  .pass-card:active{ transform:translateY(1px); }

  .drag-ghost{
    position:fixed;
    z-index:9999;
    pointer-events:none;
    transform:translate(-50%,-50%);
    opacity:.95;
  }

  /* ===== 小さい黒カード(1-12) ＋ 黒ポップ ===== */
  .power-wrapper{
    margin-top:14px;
    display:flex;
    justify-content:center;
  }
  .power-block{
    display:flex;
    gap:10px;
    align-items:flex-start;
  }
  .power-card{
    width:42px;height:60px;border-radius:10px;
    background:#111;color:#fff;
    display:flex;align-items:center;justify-content:center;
    font-weight:1000;
    font-size:22px;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    border:1px solid rgba(255,255,255,.1);
    flex:0 0 auto;
  }
  .power-pop{
    width:220px;
    height:64px;
    border-radius:14px;
    background:rgba(20,20,20,.92);
    color:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    padding:8px 10px;
    box-sizing:border-box;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:left;
    line-height:1.25;
    font-weight:900;
    overflow:hidden;
  }
  .power-pop span{
    display:block;
    width:100%;
    white-space:pre-wrap;
    word-break:break-word;
    font-size:14px;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
    min-height:calc(100vh - 60px);
  }

  /* 左下「？」 */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(560px, calc(100% - 0px));
    max-height:min(70vh, 680px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:900;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
    border-bottom:1px dashed #eee;
  }
  .role-row:last-child{border-bottom:none;}
  .role-card-mini{
    width:54px;height:76px;border-radius:10px;border:1px solid #ddd;background:#111;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:18px;font-weight:1000;color:#fff;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:1000;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* ===== コインプール（右上） ===== */
  .coin-pool{
    position:fixed;
    right:12px; top:64px;
    z-index:260;
    background:rgba(255,255,255,.92);
    border:1px solid #ddd;
    border-radius:14px;
    box-shadow:0 14px 30px rgba(0,0,0,.18);
    padding:10px;
    width:184px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .coin-pool.hidden{display:none;}
  .coin-pool-title{
    font-size:12px;
    font-weight:1000;
    opacity:.7;
    letter-spacing:.06em;
  }
  .coin-pool-inner{
    position:relative;
    width:100%;
    aspect-ratio:1 / 1;
    border-radius:12px;
    border:1px dashed rgba(0,0,0,.25);
    background:rgba(250,250,250,.7);
    overflow:hidden;
  }

  /* ★プール内の実体コイン */
  .coin{
    position:absolute;
    width:22px;height:22px;border-radius:50%;
    background:linear-gradient(180deg,#fff,#eee);
    border:1px solid rgba(0,0,0,.35);
    box-shadow:0 8px 16px rgba(0,0,0,.22);
    display:grid; place-items:center;
    font-weight:1000;
    font-size:12px;
    cursor:grab;
    user-select:none;
    touch-action:none;
    z-index:2;
  }
  .coin:active{cursor:grabbing;}
  .coin.locked{opacity:.6; cursor:not-allowed; pointer-events:none;}

  /* ★ ホスト：次ラウンド（右下・黒い四角ポップ） */
  .next-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:74px;
    height:74px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(20,20,20,.92);
    color:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    font-weight:1000;
    line-height:1.1;
    cursor:pointer;
    z-index:275;
    display:none;
  }
  .next-round-btn.visible{display:block;}

  /* ★提出マーカーを center-area より上へ */
  .played-back,
  .played-x,
  .played-front{
    z-index: 50;
  }

  /* ★効果7：霊魂カード（コインownが7のプレイヤーだけ中央に出る） */
  .spirit-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    z-index:520;
    pointer-events:none;
  }
  .spirit-overlay.hidden{display:none;}
  .spirit-card{
    width:60px;
    height:90px;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.22);
    background:#fff;
    box-shadow:0 18px 40px rgba(0,0,0,.30);
    background-size:cover;
    background-position:center;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:1000;
    cursor:grab;
    user-select:none;
    touch-action:none;
    pointer-events:auto;
  }
  .spirit-card:active{cursor:grabbing;}

/* =========================
     ★更新：効果3/4の「自分の手札シャッフル」演出
     ========================= */
  .my-hand.power34-hidden .role-card,
  .my-hand.power34-hidden .pass-card{
    opacity:0;
    pointer-events:none;
  }
  .power34-shuffle-overlay{
    position:fixed;
    inset:0;
    display:none;
    z-index:560;
    pointer-events:none;
  }
  .power34-shuffle-overlay.show{display:block;}
  .power34-shuffle-card{
    position:absolute;
    border-radius:10px;
    border:1px solid rgba(0,0,0,.22);
    background-size:cover;
    background-position:center;
    box-shadow:0 12px 24px rgba(0,0,0,.25);
    transform:translate(0,0) rotate(0deg);
    transition:transform 0.55s ease;
    will-change:transform;
  }
  .power34-shuffle-overlay.stacked .power34-shuffle-card{
    transform:translate(var(--tx), var(--ty)) rotate(var(--rot));
  }

</style>
</head>

<body>
<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<!-- ★ コイン所有：数字＆効果（公開（table/reveal2）まで表示） -->
<div id="powerBanner" class="power-banner hidden" aria-live="polite">
  <div id="powerBannerNum" class="power-banner-num">?</div>
  <div class="power-banner-body">
    <div id="powerBannerTitle" class="power-banner-title">—</div>
    <div id="powerBannerText" class="power-banner-text"></div>
  </div>
</div>

<!-- ★ 効果7：霊魂カード（コインownが7のプレイヤーだけ） -->
<div id="spiritOverlay" class="spirit-overlay hidden" aria-label="霊魂付与">
  <div id="spiritCard" class="spirit-card" title="霊魂カード">霊魂</div>
</div>

<!-- ★追加：効果3/4の強制提出時（裏面シャッフル演出） -->
<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <!-- 中央エリア -->
      <div id="centerArea" class="center-area">
        <!-- ★ discardtable（常に表示） -->
        <div id="discardTable" class="discard-table" aria-label="discardtable">
          <!-- 左上：白薔薇 -->
          <div class="discard-slot" data-slot="rose">
            <div class="slot-label">白薔薇</div>
            <div class="slot-stack" id="slotRose"></div>
          </div>
          <!-- 右上：刃 -->
          <div class="discard-slot" data-slot="blade">
            <div class="slot-label">刃</div>
            <div class="slot-stack" id="slotBlade"></div>
          </div>
          <!-- 左下：生存（信者/司教） -->
          <div class="discard-slot" data-slot="alive">
            <div class="slot-label">生存</div>
            <div class="slot-stack" id="slotAlive"></div>
          </div>
          <!-- 右下：死亡（信者/司教） -->
          <div class="discard-slot" data-slot="dead">
            <div class="slot-label">死亡</div>
            <div class="slot-stack" id="slotDead"></div>
          </div>
        </div>

        <div id="tableArea" class="table-area" aria-label="table cards">
          <div class="table-grid" id="tableGrid"></div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>

      <div class="power-wrapper" id="powerWrapper" style="display:none;">
        <div class="power-block">
          <div id="powerCard" class="power-card">?</div>
          <div class="power-pop"><span id="powerText"></span></div>
        </div>
      </div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<!-- ★ 効果7：授けますか（はい/いいえ） -->
<div id="giveDialog" class="dialog-backdrop hidden">
  <div class="dialog-box">
    <p id="giveMessage">「…」に授けますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnGiveNo">いいえ</button>
      <button class="btn primary" id="btnGiveYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="カード効果一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="カード効果一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">1〜12 効果</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーにカードを配布。<br>
    「リセット」で人数選択へ戻します（内容は後で）。<br>
    <span style="opacity:.75;">※ スタート後：提出 & コインプールが有効</span>
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="coinPool" class="coin-pool hidden">
  <div class="coin-pool-title">COIN POOL</div>
  <div id="coinPoolInner" class="coin-pool-inner"></div>
</div>

<!-- ★更新：効果3/4の手札シャッフル演出（自分だけ） -->
<div id="power34ShuffleOverlay" class="power34-shuffle-overlay" aria-hidden="true"></div>

<!-- ★ホスト：次ラウンド -->
<button id="btnNextRound" class="next-round-btn" title="次ラウンド">次<br>ラウンド</button>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

// ▼ Firebase 設定
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

// ▼ 状態
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,

  room: {},
  hands: {},
  game: {},
  plays: {},
  discard: {},

  coins: {},
  players: [],
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const giveDialog = document.getElementById('giveDialog');
const giveMessage = document.getElementById('giveMessage');
const btnGiveYes = document.getElementById('btnGiveYes');
const btnGiveNo = document.getElementById('btnGiveNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const powerWrapper = document.getElementById('powerWrapper');
const powerCardEl = document.getElementById('powerCard');
const powerTextEl = document.getElementById('powerText');

const powerBanner = document.getElementById('powerBanner');
const powerBannerNum = document.getElementById('powerBannerNum');
const powerBannerTitle = document.getElementById('powerBannerTitle');
const powerBannerText = document.getElementById('powerBannerText');

const spiritOverlay = document.getElementById('spiritOverlay');
const spiritCard = document.getElementById('spiritCard');

const coinPool = document.getElementById('coinPool');
const coinPoolInner = document.getElementById('coinPoolInner');

const discardTable = document.getElementById('discardTable');
const slotRose  = document.getElementById('slotRose');
const slotBlade = document.getElementById('slotBlade');
const slotAlive = document.getElementById('slotAlive');
const slotDead  = document.getElementById('slotDead');

const tableArea = document.getElementById('tableArea');
const tableGrid = document.getElementById('tableGrid');

const btnNextRound = document.getElementById('btnNextRound');

const power34ShuffleOverlay = document.getElementById('power34ShuffleOverlay');

/* =========================
   1〜12の効果
   ========================= */
const POWER_TEXT = {
  1: "カードを持っている人を指名する。\nその人に強制的にカードを出させる。",
  2: "このラウンドに出されたカードは、\nラウンドの最後に誰が何を出したかわかる。",
  // ★更新：あなたの指定どおり
  // ownplayer=3 のとき「影響を受けるのは逆の人」。
  // その「逆の人」のさらに向こう（時計回りに1つ先）が決めた瞬間がトリガー。
  3: "【手順は場が時計回り】\n自分が3のownplayerのとき、影響を受けるのは「逆の人」。\nその「逆の人」は自分で選べない。\nさらにその向こう（逆の人の時計回りの隣）が「出す／出さない」を決めた1秒後、\n逆の人は手札からランダムに1枚を強制提出する。\n（逆の人の手札が0なら何も起きない）",
  4: "【手順は場が時計回り】\n自分が4のownplayerのとき、自分が「出す／出さない」を決めた1秒後、\n次（右）のプレイヤーは手札からランダムに1枚を強制提出する。\n（そのプレイヤーの手札が0なら何も起きない）",
  5: "指名した二人は必ず同じ行動を行う。\n（後の人が先の人をまねる。）",
  6: "全員がカードを出し終わった後に、\n自分がカードを出すかどうか決められる。",
  7: "あなたが指名した人は幽魂一枚を得る。",
  8: "左右のプレイヤーは、カードがあれば\n必ず出さなければならない。",
  9: "暗刃の者以外は目を閉じ、\n白薔薇と司教の二人は身分を明かさずに手をあげる。",
  10:"全員がカードを出し終わった後に、一人指名する。\nその人は出したカードを違うカードと交換する。",
  11:"指定したプレイヤーのカードを\nランダムで一枚見る。",
  12:"カードを持っている人を指名する。\nその人に強制的にカードを出させる。"
};

function renderHelpList(){
  helpBody.innerHTML = '';
  for(let i=1;i<=12;i++){
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card-mini';
    card.textContent = String(i);

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${i}</div>
      <div class="text">${(POWER_TEXT[i]||'').replaceAll('<','&lt;').replaceAll('>','&gt;')}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  }
}
function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

/* =========================
   カード素材
   ========================= */
const ASSET = {
  roleFront: {
    "白薔薇": "role_shirobara.png",
    "司教": "role_shikyou.png",
    "信者": "role_shinja.png",
    "双刃": "role_soujin.png",
    "暗刃": "role_anjin.png",
    "巨刃": "role_kyogin.png",
    "霊魂": "role_reikon.png"
  },
  roleBack: "role_back.png",
  passFront: "pass.png"
};

const ROLE_PRIORITY = {
  "白薔薇": 1,
  "司教": 2,
  "信者": 3,
  "双刃": 4,
  "暗刃": 5,
  "巨刃": 6,
  "大刃": 6,
  "霊魂": 7
};
const BLADE_SET = new Set(["双刃","暗刃","巨刃","大刃"]);

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

/* UIマップ */
const ui = {
  nodeByUserId: new Map(),
  tagByUserId: new Map(),
  owncoinByUserId: new Map(),
  playedBackByUserId: new Map(),

  coinEl: null,
  ownedCoinDotByOwnerId: new Map(),
};

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    updateGameUI();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    state.game = snap.val() || {};
    updateGameUI();
    updatePowerBanner();
    updatePower7UI();
    maybeHostAdvanceRound();
    renderTableCards();
    renderPlays();
    applyPlayableAnimToMyHand();
    maybeTriggerPower34AutoPlays();
  });
}
function subscribePlays(){
  const playsRef = ref(db, `rooms/${state.roomCode}/plays`);
  onValue(playsRef, snap => {
    state.plays = snap.val() || {};
    renderPlays();
    updatePowerBanner();
    updatePower7UI();
    maybeHostAdvanceRound();
    applyPlayableAnimToMyHand();
    // ★追加：効果3/4の監視（トリガー/強制提出）
    maybeTriggerPower34AutoPlays();
    maybeFinishPower34Shuffle();
  });
}
function subscribeCoins(){
  const coinsRef = ref(db, `rooms/${state.roomCode}/coins`);
  onValue(coinsRef, snap => {
    state.coins = snap.val() || {};
    renderCoins();
    renderOwnedCoinsBadges();
    updatePowerBanner();
    updatePower7UI();
    // ★追加：効果3/4の「選べない」判定（powerDisplayが変わるので）
    applyPlayableAnimToMyHand();
  });
}
function subscribeDiscard(){
  const dRef = ref(db, `rooms/${state.roomCode}/discard`);
  onValue(dRef, snap => {
    state.discard = snap.val() || {};
    renderDiscardTable();
  });
}

function isEveryoneDecided(){
  const playerCount = (state.players || []).length;
  if (playerCount <= 0) return false;
  const playedCount = Object.keys(state.plays || {}).length;
  return playedCount === playerCount;
}

/* =========================
   ★効果3/4「選べない」判定（手順は時計回り）
   - 3: 「逆の人」が選べない（強制提出対象）
   - 4: 右（次手番）が選べない
   ========================= */
 function getSeatIndexByUid(uid){
    return (state.players || []).find(p => p.id === uid)?.seatIndex ?? null;
  }
  function getUidBySeatIndex(seatIndex){
    return (state.players || []).find(p => p.seatIndex === seatIndex)?.id || null;
  }
  function getMaxSeatCount(){
    const maxPlayers = Number(state.room?.maxPlayers || 0);
    const playerCount = (state.players || []).length;
    return maxPlayers > 0 ? maxPlayers : playerCount;
  }
  function wrapSeatIndex(seatIndex){
    const max = getMaxSeatCount();
    if (!max) return null;
    const idx = ((seatIndex - 1) % max + max) % max;
    return idx + 1;
  }
  function getRightUid(uid){
    const seatIndex = getSeatIndexByUid(uid);
    if (seatIndex == null) return null;
    const nextSeat = wrapSeatIndex(seatIndex + 1);
    if (nextSeat == null) return null;
    return getUidBySeatIndex(nextSeat);
  }
  function getLeftUid(uid){
    const seatIndex = getSeatIndexByUid(uid);
    if (seatIndex == null) return null;
    const prevSeat = wrapSeatIndex(seatIndex - 1);
    if (prevSeat == null) return null;
    return getUidBySeatIndex(prevSeat);
  }

function getDisabledUidByPower34(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  if (!started || phase !== 'collect') return null;
  if (!pd || !pd.ownerId) return null;
  const num = Number(pd.number);

  // ★更新：3は「左の人」、4は「右（次手番）」
  if (num === 3) return getLeftUid(pd.ownerId);
  if (num === 4) return getRightUid(pd.ownerId);
  return null;
}
function isMyPlayLockedByPower34(){
  const disabledUid = getDisabledUidByPower34();
  return !!(disabledUid && disabledUid === state.userId);
}

  /* =========================
     ★効果3/4 強制提出トリガー監視（手順は時計回り）
     - 3: forced=左の人
          trigger=左の人が決めた瞬間
     - 4: forced=右（次手番）
          trigger=owner が決めた瞬間
     手札0なら何も起きない（passにしない）
     二重発火防止：rooms/{room}/game/power34
     ========================= */
let power34ShuffleActive = false;
let power34ShuffleCleanupTimer = null;
let lastPower34AnimAt = 0;
let power34WaitTimer = null;
let power34WaitKey = null;
const POWER34_TRIGGER_DELAY_MS = 6000;

function clearPower34WaitTimer(){
  if (power34WaitTimer){
    clearTimeout(power34WaitTimer);
    power34WaitTimer = null;
  }
  power34WaitKey = null;
}

function clearPower34ShuffleOverlay(){
  if (power34ShuffleCleanupTimer){
    clearTimeout(power34ShuffleCleanupTimer);
    power34ShuffleCleanupTimer = null;
  }
  if (!power34ShuffleOverlay) return;
  power34ShuffleOverlay.classList.remove('stacked', 'show');
  power34ShuffleOverlay.innerHTML = '';
  myHandEl.classList.remove('power34-hidden');
  power34ShuffleActive = false;
}

function startPower34ShuffleAnim(){
  if (!power34ShuffleOverlay || power34ShuffleActive) return;
  const cards = Array.from(myHandEl.querySelectorAll('.role-card'));
  if (!cards.length) return;

  const handRect = myHandEl.getBoundingClientRect();
  const sampleRect = cards[0].getBoundingClientRect();
  const stackX = handRect.left + handRect.width / 2 - sampleRect.width / 2;
  const stackY = handRect.top + Math.min(handRect.height * 0.45, 50);

  power34ShuffleOverlay.innerHTML = '';
  power34ShuffleOverlay.classList.add('show');
  myHandEl.classList.add('power34-hidden');

  cards.forEach((card, idx) => {
    const rect = card.getBoundingClientRect();
    const overlay = document.createElement('div');
    overlay.className = 'power34-shuffle-card';
    overlay.style.width = `${rect.width}px`;
    overlay.style.height = `${rect.height}px`;
    overlay.style.left = `${rect.left}px`;
    overlay.style.top = `${rect.top}px`;
    overlay.style.backgroundImage = `url('${ASSET.roleBack}')`;
    const dx = stackX - rect.left;
    const dy = stackY - rect.top;
    const rot = (Math.random() * 18 - 9).toFixed(1);
    overlay.style.setProperty('--tx', `${dx}px`);
    overlay.style.setProperty('--ty', `${dy}px`);
    overlay.style.setProperty('--rot', `${rot}deg`);
    overlay.style.zIndex = String(560 + idx);
    power34ShuffleOverlay.appendChild(overlay);
  });

  power34ShuffleActive = true;
  requestAnimationFrame(() => {
    power34ShuffleOverlay.classList.add('stacked');
  });
}

function endPower34ShuffleAnim(){
  if (!power34ShuffleActive || !power34ShuffleOverlay) return;
  power34ShuffleOverlay.classList.remove('stacked');
  power34ShuffleCleanupTimer = setTimeout(() => {
    clearPower34ShuffleOverlay();
  }, 520);
}

async function registerPower34ForcedClick(){
  if (!state.roomCode) return;

  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect') return;

  const pd = state.game?.powerDisplay || null;
  if (!pd || !pd.ownerId) return;

  const num = Number(pd.number);
  if (num !== 3 && num !== 4) return;

  const round = Number(state.game?.round || 1);
  const base = `rooms/${state.roomCode}`;
  const forcedUid = (num === 3) ? getLeftUid(pd.ownerId) : getRightUid(pd.ownerId);
  if (!forcedUid || forcedUid !== state.userId) return;

  const triggerUid = (num === 3) ? getLeftUid(forcedUid) : pd.ownerId;
  if (!triggerUid) return;

  const triggerPlay = state.plays?.[triggerUid] || null;
  const triggerAt = Number(triggerPlay?.playedAt || 0);
  if (!triggerAt) return;

  const p34Ref = ref(db, `${base}/game/power34`);
  await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    if (c.round !== round || c.ownerId !== pd.ownerId || Number(c.number) !== num){
      return {
        round,
        ownerId: pd.ownerId,
        number: num,
        triggerUid,
        forcedUid,
        triggerAt,
        done: false,
        claimedBy: null,
        claimedAt: null,
        clickedBy: state.userId,
        clickedAt: Date.now()
      };
    }

    if (c.done) return c;
    if (c.triggerUid !== triggerUid || c.forcedUid !== forcedUid || Number(c.triggerAt) !== triggerAt){
      return {
        round,
        ownerId: pd.ownerId,
        number: num,
        triggerUid,
        forcedUid,
        triggerAt,
        done: false,
        claimedBy: null,
        claimedAt: null,
        clickedBy: state.userId,
        clickedAt: Date.now()
      };
    }

    if (!c.clickedAt){
      c.clickedBy = state.userId;
      c.clickedAt = Date.now();
    }
    return c;
  });
}

async function maybeTriggerPower34AutoPlays(){
  if (!state.roomCode) return;


  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  if (!started || phase !== 'collect'){
    clearPower34WaitTimer();
    return;
  }

  const pd = state.game?.powerDisplay || null;
  if (!pd || !pd.ownerId){
    clearPower34WaitTimer();
    return;
  }

  const num = Number(pd.number);
  if (num !== 3 && num !== 4){
    clearPower34WaitTimer();
    return;
  }

  const round = Number(state.game?.round || 1);
  const base = `rooms/${state.roomCode}`;

  // ★更新：num=3は「左」、num=4は「右（次手番）」
  const forcedUid = (num === 3) ? getLeftUid(pd.ownerId) : getRightUid(pd.ownerId);

  if (!forcedUid){
    clearPower34WaitTimer();
    return;
  }

  const triggerUid = (num === 3) ? getLeftUid(forcedUid) : pd.ownerId;

  if (!triggerUid){
    clearPower34WaitTimer();
    return;
  }

  // すでに forcedUid が提出してたら不要
  if (state.plays?.[forcedUid]){
    clearPower34WaitTimer();
    return;
  }

  const triggerPlay = state.plays?.[triggerUid] || null;
  if (!triggerPlay){
    clearPower34WaitTimer();
    return;
  }

  // triggerPlay の 6秒後に実行（ただし1回だけ）
  const triggerAt = Number(triggerPlay.playedAt || 0);
  if (!triggerAt){
    clearPower34WaitTimer();
    return;
  }

  const now = Date.now();

  const p34State = state.game?.power34 || null;
  const hasForcedClick = !!(
    p34State &&
    p34State.clickedAt &&
    p34State.triggerUid === triggerUid &&
    p34State.forcedUid === forcedUid &&
    Number(p34State.triggerAt) === triggerAt &&
    Number(p34State.number) === num &&
    p34State.ownerId === pd.ownerId
  );

  // 6秒未満なら「残り時間後に必ず再チェック」
  if (!hasForcedClick && now - triggerAt < POWER34_TRIGGER_DELAY_MS){
    const remain = POWER34_TRIGGER_DELAY_MS - (now - triggerAt);
    const key = `${round}|${num}|${pd.ownerId}|${triggerUid}|${forcedUid}|${triggerAt}`;
    if (power34WaitKey !== key){
      clearPower34WaitTimer();
      power34WaitKey = key;
      power34WaitTimer = setTimeout(() => {
        power34WaitTimer = null;
        power34WaitKey = null;
        maybeTriggerPower34AutoPlays();
      }, remain + 40);
    }
    return;
  } else {
    clearPower34WaitTimer();
  }

  const p34Ref = ref(db, `${base}/game/power34`);

  const claim = await runTransaction(p34Ref, (cur) => {
    const c = cur || {};
    if (c.round !== round || c.ownerId !== pd.ownerId || Number(c.number) !== num){
      return {
        round,
        ownerId: pd.ownerId,
        number: num,
        triggerUid,
        forcedUid,
        triggerAt,
        done: false,
        claimedBy: null,
        claimedAt: null
      };
    }

    if (c.done) return c;

    if (c.triggerUid !== triggerUid || c.forcedUid !== forcedUid || Number(c.triggerAt) !== triggerAt){
      return {
        round,
        ownerId: pd.ownerId,
        number: num,
        triggerUid,
        forcedUid,
        triggerAt,
        done:false,
        claimedBy:null,
        claimedAt:null
      };
    }

    if (c.claimedBy) return c;

    c.claimedBy = state.userId;
    c.claimedAt = Date.now();
    return c;
  });

  const p34 = claim.snapshot.val() || null;
  if (!claim.committed || !p34) return;

  if (p34.claimedBy !== state.userId) return;

  const playsSnap = await get(ref(db, `${base}/plays`));
  const playsNow = playsSnap.val() || {};
  if (playsNow[forcedUid]){
    await update(p34Ref, { done:true, doneAt: Date.now() });
    return;
  }

  // forcedUid の手札からランダムで1枚
  const handSnap = await get(ref(db, `${base}/hands/${forcedUid}/roleCards`));
  const arr = handSnap.val();
  const roleCards = Array.isArray(arr) ? [...arr] : [];
  if (!roleCards.length){
    // ★仕様：手札0なら「何も起きない」
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'nohand' });
    return;
  }

  const pick = roleCards[Math.floor(Math.random() * roleCards.length)];

  await update(p34Ref, { animAt: Date.now() });

  const okTx = await runTransaction(ref(db, `${base}/hands/${forcedUid}/roleCards`), (current) => {
    const a = Array.isArray(current) ? [...current] : [];
    const idx = a.indexOf(pick);
    if (idx === -1) return;
    a.splice(idx, 1);
    return a;
  });

  if (!okTx.committed){
    await update(p34Ref, { done:true, doneAt: Date.now(), result:'fail_remove' });
    return;
  }

  const forcedSeat = (state.players || []).find(p => p.id === forcedUid)?.seatIndex || 0;

  await set(ref(db, `${base}/plays/${forcedUid}`), {
    kind: 'role',
    card: pick,
    seatIndex: forcedSeat,
    playedAt: Date.now(),
    forcedBy: 'power34',
    forcedFrom: num
  });

  await update(p34Ref, { done:true, doneAt: Date.now(), result:'ok', forcedCard: pick });
}

/* ★ power34.animAt を購読して演出表示 */
function subscribePower34Anim(){
  const p34Ref = ref(db, `rooms/${state.roomCode}/game/power34`);
  onValue(p34Ref, snap => {
    const v = snap.val();
    if (!v) return;
    const started = !!state.game?.started;
    const phase = state.game?.phase || 'collect';
    if (!started || phase !== 'collect') return;
    if (v.animAt && typeof v.animAt === 'number' && v.forcedUid === state.userId){
      if (v.animAt > lastPower34AnimAt && Date.now() - v.animAt < 2000){
        lastPower34AnimAt = v.animAt;
        startPower34ShuffleAnim();
      }
    }
  });
}

function maybeFinishPower34Shuffle(){
  if (!power34ShuffleActive) return;
  const play = state.plays?.[state.userId];
  if (!play) return;
  if (play.forcedBy === 'power34'){
    endPower34ShuffleAnim();
  }
}


/* =========================
   ★プレイ可能な手札なら大小アニメ
   （効果3/4で選べない人は playable を付けない）
   ========================= */
function isRolePlayableNow(){
  if (!state.game?.started) return false;
  const phase = state.game?.phase || 'collect';
  if (phase !== 'collect') return false;
  if (isEveryoneDecided()) return false;
  if (isMyPlayLockedByPower34()) return false;
  return true;
}
function applyPlayableAnimToMyHand(){
  const playable = isRolePlayableNow();
  myHandEl.querySelectorAll('.role-card').forEach(el => {
    el.classList.toggle('playable', playable);
  });
}

/* ★変更：コインown後のバナーは「公開（table/reveal2）まで」表示し続ける */
function updatePowerBanner(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;

  const shouldShow = started && !!pd && (phase !== 'table') && (phase !== 'reveal2');
  powerBanner.classList.toggle('hidden', !shouldShow);
  if (!shouldShow) return;

  const ownerId = pd.ownerId;
  const number = Number(pd.number);
  const ownerName = (state.players || []).find(p => p.id === ownerId)?.name || '誰か';

  powerBannerNum.textContent = (Number.isFinite(number) ? String(number) : '?');
  powerBannerTitle.textContent = `${ownerName} の効果`;
  powerBannerText.textContent = POWER_TEXT[number] || '';
}

function updateGameUI(){
  const started = !!state.game.started;
  coinPool.classList.toggle('hidden', !started);

  const phase = state.game.phase || 'collect';

  tableArea.classList.toggle('show', started && phase === 'table');

  btnNextRound.classList.toggle('visible', !!(started && state.isHost && (phase === 'table' || phase === 'reveal2')));

  applyPlayableAnimToMyHand();
}

function renderHands(){
  renderMyHand();
  if (state.players.length) renderPlayerCircle(state.players);
  renderPlays();
  renderCoins();
  renderOwnedCoinsBadges();
  renderDiscardTable();
  renderTableCards();
  updatePower7UI();
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myId = state.userId;
  const handData = state.hands[myId];
  const started = !!state.game.started;

  if (started && handData && Array.isArray(handData.roleCards)) {
    handData.roleCards.forEach((name, idx) => {
      const card = document.createElement('div');
      card.className = 'role-card';
      card.dataset.role = name;
      card.dataset.index = String(idx);

      const face = document.createElement('div');
      face.className = 'face';
      face.style.backgroundImage = `url('${ASSET.roleFront[name] || ''}')`;

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = name;

      card.appendChild(face);
      card.appendChild(label);

      card.addEventListener('pointerdown', (e) => {
        registerPower34ForcedClick();
        startDragCard(e, { kind:'role', cardName:name });
      });
      myHandEl.appendChild(card);
    });

    const pass = document.createElement('div');
    pass.className = 'pass-card';
    pass.dataset.pass = "1";
    pass.innerHTML = `<div class="label">出さない</div>`;
    pass.addEventListener('click', async (e) => {
      e.stopPropagation();
      await setMyPlay({ kind:'pass' });
    });
    myHandEl.appendChild(pass);
  }

  if (started && handData && handData.numberCard) {
    const n = Number(handData.numberCard);
    powerWrapper.style.display = '';
    powerCardEl.textContent = String(n);
    powerTextEl.textContent = POWER_TEXT[n] || '';
    fitTextToBox(powerTextEl, 14, 9);
  } else {
    powerWrapper.style.display = 'none';
  }

  applyPlayableAnimToMyHand();
}

function fitTextToBox(spanEl, maxPx=14, minPx=9){
  if (!spanEl) return;
  const box = spanEl.parentElement;
  if (!box) return;

  let size = maxPx;
  spanEl.style.fontSize = size + 'px';
  while (size > minPx && (spanEl.scrollHeight > box.clientHeight || spanEl.scrollWidth > box.clientWidth)) {
    size -= 1;
    spanEl.style.fontSize = size + 'px';
  }
}

/* =========================
   入室
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeGame();
  subscribePlays();
  subscribeCoins();
  subscribeDiscard();

  // ★追加：power34.anim購読
  subscribePower34Anim();

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* =========================
   着席UI
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=10; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 10;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   プレイヤー購読 & 円描画
   ========================= */
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    state.players = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
    renderPlays();
    renderCoins();
    renderOwnedCoinsBadges();
    updatePowerBanner();
    updatePower7UI();

    maybeHostAdvanceRound();
    applyPlayableAnimToMyHand();
  });
}

function renderPlayerCircle(players){
  playerCircle.querySelectorAll('.player-node').forEach(el => el.remove());
  ui.nodeByUserId.clear();
  ui.tagByUserId.clear();
  ui.owncoinByUserId.clear();

  if (!players.length) return;

  const n = players.length;
  const radiusPct = 44;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radiusPct * Math.cos(angle);
    const y = 50 + radiusPct * Math.sin(angle);

    const node = document.createElement('div');
    node.className = 'player-node';
    node.dataset.uid = p.id;
    node.style.left = `${x}%`;
    node.style.top  = `${y}%`;

    const owncoin = document.createElement('div');
    owncoin.className = 'owncoin';

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;

    const ownedCoins = document.createElement('div');
    ownedCoins.className = 'owned-coins';

    node.addEventListener('click', () => {
      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    });

    const handData = state.hands[p.id];
    const roleCount = (handData && Array.isArray(handData.roleCards)) ? handData.roleCards.length : 0;
    if (p.id !== state.userId && roleCount > 0){
      const miniHand = document.createElement('div');
      miniHand.className = 'mini-hand';

      const count = roleCount;
      const spread = 70;
      const base = (count > 1) ? (-spread/2) : 0;

      for (let i=0;i<count;i++){
        const c = document.createElement('div');
        c.className = 'mini-card';
        c.textContent = '';

        const angleDeg = (count > 1) ? base + (spread/(count-1))*i : 0;
        c.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
        c.style.zIndex = String(10 + i);
        miniHand.appendChild(c);
      }
      tag.appendChild(miniHand);
    }

    node.appendChild(owncoin);
    node.appendChild(tag);
    node.appendChild(ownedCoins);
    playerCircle.appendChild(node);

    ui.nodeByUserId.set(p.id, node);
    ui.tagByUserId.set(p.id, tag);
    ui.owncoinByUserId.set(p.id, owncoin);
  });

  renderOwnedCoinsBadges();
}

/* =========================
   追い出しダイアログ
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   効果7：授けますかダイアログ
   ========================= */
let pendingGiveTargetId = null;
let pendingGiveTargetName = null;

giveDialog.addEventListener('click', (e) => {
  if (e.target === giveDialog) {
    giveDialog.classList.add('hidden');
    pendingGiveTargetId = null;
    pendingGiveTargetName = null;
  }
});
btnGiveNo.addEventListener('click', (e) => {
  e.stopPropagation();
  giveDialog.classList.add('hidden');
  pendingGiveTargetId = null;
  pendingGiveTargetName = null;
});
btnGiveYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (!state.roomCode) return;
  if (!pendingGiveTargetId) {
    giveDialog.classList.add('hidden');
    return;
  }

  const p7 = state.game?.power7 || null;
  if (p7 && p7.used) {
    giveDialog.classList.add('hidden');
    pendingGiveTargetId = null;
    pendingGiveTargetName = null;
    updatePower7UI();
    return;
  }

  const targetId = pendingGiveTargetId;

  await runTransaction(ref(db, `rooms/${state.roomCode}/hands/${targetId}/roleCards`), (cur) => {
    const arr = Array.isArray(cur) ? [...cur] : [];
    arr.push("霊魂");
    return arr;
  });

  await runTransaction(ref(db, `rooms/${state.roomCode}/game/power7`), (cur) => {
    const round = Number(state.game?.round || cur?.round || 1);
    const giverId = state.game?.powerDisplay?.ownerId || cur?.giverId || null;
    if (!cur || cur.round !== round || cur.giverId !== giverId) {
      return { round, giverId, used:true, targetId, grantedAt: Date.now() };
    }
    if (cur.used) return cur;
    cur.used = true;
    cur.targetId = targetId;
    cur.grantedAt = Date.now();
    return cur;
  });

  giveDialog.classList.add('hidden');
  pendingGiveTargetId = null;
  pendingGiveTargetName = null;
  updatePower7UI();
});

/* =========================
   ゲーム開始：配布 + コイン生成（1個） + discard初期化
   ========================= */
function buildRoleHandsForPlayers(playerIds){
  const n = playerIds.length;

  const basePatterns = [
    ["白薔薇","信者","霊魂"],
    ["双刃","双刃","信者"],
    ["信者","信者","霊魂"],
    ["暗刃","信者","霊魂"],
  ];

  let extraCount = 0;
  if (n === 7) extraCount = 1;
  if (n === 8) extraCount = 1;
  if (n === 9) extraCount = 2;
  if (n === 10) extraCount = 2;

  const extraPattern = ["巨刃","信者","霊魂"];

  const hands = {};
  for (let i=0;i<n;i++){
    if (i < basePatterns.length) hands[playerIds[i]] = [...basePatterns[i]];
    else hands[playerIds[i]] = ["信者","信者","霊魂"];
  }
  for (let k=0;k<extraCount;k++){
    const idx = basePatterns.length + k;
    if (idx < n){
      hands[playerIds[idx]] = [...extraPattern];
    }
  }
  return hands;
}

function shuffleArray(arr){
  const a = [...arr];
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}

async function startGameDeal(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? { id:t.playerId, seatIndex:Number(seatIndex) } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  const playerIds = players.map(p=>p.id);
  if (!playerIds.length) return;

  const roleHands = buildRoleHandsForPlayers(playerIds);

  const deck = shuffleArray(Array.from({length:12}, (_,i)=>i+1));
  const hands = {};
  playerIds.forEach((uid, i) => {
    hands[uid] = {
      roleCards: roleHands[uid] || ["信者","信者","霊魂"],
      numberCard: deck[i % deck.length]
    };
  });

  const coins = {
    coin1: {
      xPct: 0.5,
      yPct: 0.5,
      lockBy: null,
      ownerId: null,
      updatedAt: Date.now()
    }
  };

  const discard = { rose: [], blade: [], alive: [], dead: [] };

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/plays`), null),
    set(ref(db, `${base}/coins`), coins),
    set(ref(db, `${base}/discard`), discard),
    update(ref(db, `${base}/game`), {
      started: true,
      round: (state.game.round || 0) + 1,
      phase: "collect",
      powerDisplay: null,
      power7: null,
      power34: null,
      tableList: null,
      waitStartedAt: null,
      shuffleStartedAt: null,
      startedAt: Date.now()
    })
  ]);
}

/* =========================
   提出（plays）描画：プレイヤー→中央方向のマーカー
   ========================= */
function renderPlays(){
  renderPlayedMarkers();
  applyPlayableAnimToMyHand();
}

function hashToNumber(str){
  let h = 0;
  for (let i = 0; i < str.length; i++){
    h = ((h << 5) - h) + str.charCodeAt(i);
    h |= 0;
  }
  return Math.abs(h);
}

function setShuffleVars(el, uid){
  const base = hashToNumber(uid);
  const jitter = (offset, range) => {
    const v = Math.sin(base + offset) * 10000;
    return (v - Math.floor(v)) * range * 2 - range;
  };
  el.style.setProperty('--sx1', `${jitter(1, 12).toFixed(1)}px`);
  el.style.setProperty('--sy1', `${jitter(2, 10).toFixed(1)}px`);
  el.style.setProperty('--sr1', `${jitter(3, 12).toFixed(1)}deg`);
  el.style.setProperty('--sx2', `${jitter(4, 16).toFixed(1)}px`);
  el.style.setProperty('--sy2', `${jitter(5, 14).toFixed(1)}px`);
  el.style.setProperty('--sr2', `${jitter(6, 16).toFixed(1)}deg`);
  el.style.setProperty('--sx3', `${jitter(7, 10).toFixed(1)}px`);
  el.style.setProperty('--sy3', `${jitter(8, 12).toFixed(1)}px`);
  el.style.setProperty('--sr3', `${jitter(9, 10).toFixed(1)}deg`);
}

function renderPlayedMarkers(){
  const plays = state.plays || {};
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const isShuffle = started && phase === 'shuffle';
  const isReveal2 = started && phase === 'reveal2';

  const isTable = started && phase === 'table';

  for (const [uid, el] of ui.playedBackByUserId){
    if (!plays[uid] || isTable) {
      el.remove();
      ui.playedBackByUserId.delete(uid);
    }
  }
  if (isTable) return;

  const circleRect = playerCircle.getBoundingClientRect();
  const centerX = circleRect.left + circleRect.width/2;
  const centerY = circleRect.top  + circleRect.height/2;
  const discardRect = discardTable.getBoundingClientRect();
  const shuffleX = discardRect.left + discardRect.width/2;
  const shuffleY = discardRect.top + discardRect.height/2;

  for (const uid of Object.keys(plays)){

    const p = plays[uid];
    if (!p) continue;

    const node = ui.nodeByUserId.get(uid);
    if (!node) continue;

    const nodeRect = node.getBoundingClientRect();
    const tagCX = nodeRect.left + nodeRect.width/2;
    const tagCY = nodeRect.top  + nodeRect.height/2;

    const t = 0.62;
    const x = centerX + (tagCX - centerX) * t;
    const y = centerY + (tagCY - centerY) * t;

    let marker = ui.playedBackByUserId.get(uid);

    const wantKind = (p.kind === 'pass') ? 'pass' : (isReveal2 ? 'front' : 'role');
    const haveKind = marker?.dataset?.kind || null;
    if (marker && haveKind !== wantKind){
      marker.remove();
      ui.playedBackByUserId.delete(uid);
      marker = null;
    }

    if (!marker){
      if (p.kind === 'pass'){
        marker = document.createElement('div');
        marker.className = 'played-x';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'pass';
        marker.textContent = '✕';
      } else if (isReveal2){
        marker = document.createElement('div');
        marker.className = 'played-front';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'front';

        const tEl = document.createElement('div');
        tEl.className = 't';
        tEl.textContent = p.card || '';
        marker.appendChild(tEl);
      } else {
        marker = document.createElement('div');
        marker.className = 'played-back';
        marker.dataset.uid = uid;
        marker.dataset.kind = 'role';

        const bk = document.createElement('div');
        bk.className = 'bk';
        bk.style.backgroundImage = `url('${ASSET.roleBack}')`;
        marker.appendChild(bk);
      }

      document.body.appendChild(marker);
      ui.playedBackByUserId.set(uid, marker);
    }

    marker.style.left = `${x}px`;
    marker.style.top  = `${y}px`;

 if (isShuffle){
      setShuffleVars(marker, uid);
      marker.classList.add('shuffling');
      marker.style.left = `${shuffleX}px`;
      marker.style.top  = `${shuffleY}px`;
    } else {
      marker.classList.remove('shuffling');
      marker.style.left = `${x}px`;
      marker.style.top  = `${y}px`;
    }

    if (p.kind === 'pass'){
      if (isShuffle){
        marker.style.transform = 'translate(-50%,-50%)';
      } else {
        marker.style.transform = `translate(-50%,-50%)` + (isReveal2 ? ' scale(0.7)' : '');
      }
    } else if (isReveal2){
      marker.style.backgroundImage = `url('${ASSET.roleFront[p.card] || ''}')`;
      marker.style.transform = `translate(-50%,-50%) scale(0.7)`;
    } else {
      if (isShuffle){
        marker.style.transform = 'translate(-50%,-50%)';
      } else {
        marker.style.transform = `translate(-50%,-50%) rotate(${(p.seatIndex||0)*3}deg)`;
      }
    }
  }
}


/* =========================
   ★全員提出後：3秒 → shuffle → table
   ただし 効果2 の場合：3秒 → reveal2（表でその位置に表示、シャッフルもtableも無し）
   ========================= */
let hostPhaseTimer = null;
let hostAdvanceBusy = false;

function clearHostPhaseTimer(){
  if (hostPhaseTimer){
    clearTimeout(hostPhaseTimer);
    hostPhaseTimer = null;
  }
}

function buildTableListFromPlaysShuffled(playsObj){
  const raw = Object.entries(playsObj || {})
    .map(([uid, p]) => {
      if (!p) return null;
      return {
        uid,
        kind: p.kind === 'pass' ? 'pass' : 'role',
        card: p.kind === 'pass' ? null : (p.card || null),
        seatIndex: Number(p.seatIndex ?? 0),
        playedAt: Number(p.playedAt || 0)
      };
    })
    .filter(Boolean);

  return shuffleArray(raw);
}

function buildTableListFromPlaysNoShuffle(playsObj){
  const raw = Object.entries(playsObj || {})
    .map(([uid, p]) => {
      if (!p) return null;
      return {
        uid,
        kind: p.kind === 'pass' ? 'pass' : 'role',
        card: p.kind === 'pass' ? null : (p.card || null),
        seatIndex: Number(p.seatIndex ?? 0),
        playedAt: Number(p.playedAt || 0)
      };
    })
    .filter(Boolean);

  raw.sort((a,b) => (a.seatIndex - b.seatIndex) || (a.playedAt - b.playedAt));
  return raw;
}

async function hostStepWaitToNext(){
  if (!state.isHost || !state.roomCode) return;
  if (hostAdvanceBusy) return;
  hostAdvanceBusy = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const [gameSnap, playsSnap, tablesSnap] = await Promise.all([
      get(ref(db, `${base}/game`)),
      get(ref(db, `${base}/plays`)),
      get(ref(db, `${base}/tables`)),
    ]);

    const game = gameSnap.val() || {};
    const plays = playsSnap.val() || {};
    const tables = tablesSnap.val() || {};

    if (!game.started) return;
    if ((game.phase || 'collect') !== 'wait') return;

    const players = Object.entries(tables)
      .map(([seatIndex, t]) => (t && t.playerId ? ({ id:t.playerId, seatIndex:Number(seatIndex) }) : null))
      .filter(Boolean);

    const playerCount = players.length;
    const playedCount = Object.keys(plays || {}).length;

    if (playerCount <= 0 || playedCount !== playerCount) return;

    const powerNum = Number(game?.powerDisplay?.number ?? null);

    if (powerNum === 2){
      const tableList = buildTableListFromPlaysNoShuffle(plays);
      await update(ref(db, `${base}/game`), {
        phase: 'reveal2',
        tableList,
        shuffleStartedAt: null
      });
      return;
    }

    const tableList = buildTableListFromPlaysShuffled(plays);
    await update(ref(db, `${base}/game`), {
      phase: 'shuffle',
      shuffleStartedAt: Date.now(),
      tableList
    });
  } finally {
    hostAdvanceBusy = false;
  }
}

async function hostStepShuffleToTable(){
  if (!state.isHost || !state.roomCode) return;
  if (hostAdvanceBusy) return;
  hostAdvanceBusy = true;
  try{
    const base = `rooms/${state.roomCode}`;
    const gameSnap = await get(ref(db, `${base}/game`));
    const game = gameSnap.val() || {};
    if (!game.started) return;
    if ((game.phase || 'collect') !== 'shuffle') return;

    await update(ref(db, `${base}/game`), { phase: 'table' });
  } finally {
    hostAdvanceBusy = false;
  }
}

function maybeHostAdvanceRound(){
  if (!state.isHost || !state.game.started){
    clearHostPhaseTimer();
    return;
  }

  clearHostPhaseTimer();

  const phase = state.game.phase || 'collect';
  const players = state.players || [];
  const playerCount = players.length;
  if (playerCount <= 0) return;

  const plays = state.plays || {};
  const playedCount = Object.keys(plays).length;

  if (phase === 'collect' && playedCount === playerCount){
    update(ref(db, `rooms/${state.roomCode}/game`), {
      phase: 'wait',
      waitStartedAt: Date.now()
    });
    return;
  }

  if (phase === 'wait'){
    const t = Number(state.game.waitStartedAt || 0);
    const now = Date.now();
    const remain = (t ? (3000 - (now - t)) : 0);

    if (remain <= 0){
      hostStepWaitToNext();
    } else {
      hostPhaseTimer = setTimeout(() => {
        hostPhaseTimer = null;
        hostStepWaitToNext();
      }, remain + 30);
    }
    return;
  }

  if (phase === 'shuffle'){
    const t = Number(state.game.shuffleStartedAt || 0);
    const now = Date.now();
    const remain = (t ? (1000 - (now - t)) : 0);

    if (remain <= 0){
      hostStepShuffleToTable();
    } else {
      hostPhaseTimer = setTimeout(() => {
        hostPhaseTimer = null;
        hostStepShuffleToTable();
      }, remain + 20);
    }
    return;
  }
}

/* =========================
   ★中央に並べる（tableList） ※phase=tableのみ
   ========================= */
function renderTableCards(){
  const started = !!state.game.started;
  const phase = state.game.phase || 'collect';
  const list = Array.isArray(state.game.tableList) ? state.game.tableList : [];

  tableGrid.innerHTML = '';
  if (!started || phase !== 'table') return;

  list.forEach(item => {
    const el = document.createElement('div');
    const isPass = (item.kind === 'pass');
    el.className = 'table-card' + (isPass ? ' pass' : '');
    if (isPass){
      el.textContent = '✕';
    } else {
      el.textContent = item.card || '';
      el.style.backgroundImage = `url('${ASSET.roleFront[item.card] || ''}')`;
    }
    tableGrid.appendChild(el);
  });
}

/* =========================
   ★ discardtable（積み上げ表示）
   ========================= */
function ensureArray(v){ return Array.isArray(v) ? v : []; }

function renderStackInto(slotEl, items, mode){
  slotEl.innerHTML = '';
  const arr = ensureArray(items);
  arr.forEach((it, idx) => {
    const card = document.createElement('div');
    const isPass = (it.kind === 'pass');
    card.className = 'stack-card' + (isPass ? ' pass' : '') + (it.dead ? ' dead' : '');
    if (isPass){
      card.textContent = '✕';
    } else {
      card.textContent = it.card || '';
      card.style.backgroundImage = `url('${ASSET.roleFront[it.card] || ''}')`;
    }

    const step = 7;
    let dy = 0;
    if (mode === 'down') dy = step * idx;
    if (mode === 'up') dy = -step * idx;

    card.style.transform = `translate(-50%,-50%) translateY(${dy}px)`;
    card.style.zIndex = String(10 + idx);
    slotEl.appendChild(card);
  });
}

function renderDiscardTable(){
  const d = state.discard || {};
  renderStackInto(slotRose,  d.rose,  'down');
  renderStackInto(slotBlade, d.blade, 'up');
  renderStackInto(slotAlive, d.alive, 'down');
  renderStackInto(slotDead,  d.dead,  'down');
}

/* =========================
   ★ホスト：次ラウンド
   ========================= */
btnNextRound.addEventListener('click', async () => {
  if (!state.isHost) return;
  if (!state.roomCode) return;
  const phase = state.game.phase || 'collect';
  if (phase !== 'table' && phase !== 'reveal2') return;

  const base = `rooms/${state.roomCode}`;
  const gameSnap = await get(ref(db, `${base}/game`));
  const game = gameSnap.val() || {};
  const list = Array.isArray(game.tableList) ? game.tableList : [];
  const round = Number(game.round || 1);

  const bladePlayed = list.some(it => it && it.kind === 'role' && BLADE_SET.has(it.card));

  const toRose = [];
  const toBlade = [];
  const toAlive = [];
  const toDead = [];

  for (const it of list){
    if (!it) continue;
    if (it.kind !== 'role') continue;

    const card = it.card;
    if (!card) continue;

    if (card === '霊魂') continue;
    if (BLADE_SET.has(card)){
      toBlade.push({ kind:'role', card, round, addedAt: Date.now() });
      continue;
    }

    if (card === '白薔薇'){
      const dead = !!bladePlayed;
      toRose.push({ kind:'role', card, dead, round, addedAt: Date.now() });
      continue;
    }

    if (card === '司教' || card === '信者'){
      const dead = !!bladePlayed;
      if (dead) toDead.push({ kind:'role', card, round, addedAt: Date.now() });
      else toAlive.push({ kind:'role', card, round, addedAt: Date.now() });
      continue;
    }
  }

  const dRef = ref(db, `${base}/discard`);
  await runTransaction(dRef, (cur) => {
    const d = cur || {};
    d.rose  = ensureArray(d.rose);
    d.blade = ensureArray(d.blade);
    d.alive = ensureArray(d.alive);
    d.dead  = ensureArray(d.dead);

    d.rose.push(...toRose);
    d.blade.push(...toBlade);
    d.alive.push(...toAlive);
    d.dead.push(...toDead);
    return d;
  });

  await Promise.all([
    set(ref(db, `${base}/plays`), null),
    update(ref(db, `${base}/game`), {
      round: round + 1,
      phase: 'collect',
      powerDisplay: null,
      power7: null,
      power34: null,
      tableList: null,
      waitStartedAt: null,
      shuffleStartedAt: null
    })
  ]);
});

/* =========================
   提出（正体カードドラッグ）/ 出さない（クリック）
   ========================= */
let drag = null;

function startDragCard(e, payload){
  if (!state.game.started) return;

  const phase = state.game.phase || 'collect';
  if (phase !== 'collect') return;
  if (isEveryoneDecided()) return;
  if (payload.kind !== 'role') return;

  // ★効果3/4で選べない人はドラッグ不可
  if (isMyPlayLockedByPower34()) return;

  const target = e.currentTarget;
  if (!(target instanceof HTMLElement)) return;

  e.preventDefault();
  target.setPointerCapture?.(e.pointerId);

  target.classList.add('dragging');

  const ghost = target.cloneNode(true);
  ghost.classList.add('drag-ghost');
  document.body.appendChild(ghost);

  drag = {
    ghost,
    kind: payload.kind,
    cardName: payload.cardName,
    pointerId: e.pointerId,
    srcEl: target
  };

  moveGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!drag || ev.pointerId !== drag.pointerId) return;
    moveGhost(ev.clientX, ev.clientY);
  };
  const onUp = async (ev) => {
    if (!drag || ev.pointerId !== drag.pointerId) return;

    const dropped = isOverDiscardTable(ev.clientX, ev.clientY);

    drag.srcEl?.classList.remove('dragging');

    drag.ghost.remove();
    drag = null;

    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    if (!dropped) return;
    await setMyPlay({ kind:'role', cardName: payload.cardName });
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

function moveGhost(x, y){
  if (!drag) return;
  drag.ghost.style.left = `${x}px`;
  drag.ghost.style.top  = `${y}px`;
}

function isOverDiscardTable(x, y){
  const r = discardTable.getBoundingClientRect();
  return (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom);
}

async function setMyPlay({ kind, cardName=null }){
  if (!state.roomCode) return;
  if (!state.game.started) return;

  const phase = state.game.phase || 'collect';
  if (phase !== 'collect') return;
  if (isEveryoneDecided()) return;

  // ★効果3/4で選べない人は「出さない」も不可
  if (isMyPlayLockedByPower34()) return;

  const uid = state.userId;
  const old = state.plays?.[uid] || null;

  const roleRef = ref(db, `rooms/${state.roomCode}/hands/${uid}/roleCards`);
  const newIsRole = (kind === 'role');
  const oldIsRole = (old && old.kind === 'role' && old.card);

  const tx = await runTransaction(roleRef, (current) => {
    let arr = Array.isArray(current) ? [...current] : [];
    if (oldIsRole) arr.push(old.card);
    if (newIsRole){
      const idx = arr.indexOf(cardName);
      if (idx === -1) return;
      arr.splice(idx, 1);
    }
    return arr;
  });

  if (!tx.committed) return;

  const seatIndex = state.seatedTable || 0;
  await set(ref(db, `rooms/${state.roomCode}/plays/${uid}`), {
    kind: newIsRole ? 'role' : 'pass',
    card: newIsRole ? cardName : null,
    seatIndex,
    playedAt: Date.now()
  });
}

/* =========================
   ★コイン：いつでもドラッグ可能（既存仕様）
   ========================= */
const COIN_ID = 'coin1';
const COIN_SIZE = 22;
const COIN_PAD = 6;

let coinDrag = null;

function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
function rectContainsPoint(rect, x, y){
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function pctFromClientXY(clientX, clientY){
  const rect = coinPoolInner.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const usableW = Math.max(1, w - COIN_SIZE - COIN_PAD*2);
  const usableH = Math.max(1, h - COIN_SIZE - COIN_PAD*2);

  let left = (clientX - rect.left) - COIN_SIZE/2;
  let top  = (clientY - rect.top)  - COIN_SIZE/2;

  left = clamp(left, COIN_PAD, COIN_PAD + usableW);
  top  = clamp(top,  COIN_PAD, COIN_PAD + usableH);

  const xPct = (left - COIN_PAD) / usableW;
  const yPct = (top  - COIN_PAD) / usableH;

  return { xPct, yPct };
}

function placeCoinByPct(el, xPct, yPct){
  const w = coinPoolInner.clientWidth;
  const h = coinPoolInner.clientHeight;

  const usableW = Math.max(1, w - COIN_SIZE - COIN_PAD*2);
  const usableH = Math.max(1, h - COIN_SIZE - COIN_PAD*2);

  const left = COIN_PAD + usableW * clamp(Number(xPct ?? 0.5), 0, 1);
  const top  = COIN_PAD + usableH * clamp(Number(yPct ?? 0.5), 0, 1);

  el.style.left = `${left}px`;
  el.style.top  = `${top}px`;
}

function ensurePoolCoinEl(){
  if (ui.coinEl) return ui.coinEl;

  const el = document.createElement('div');
  el.className = 'coin';
  el.dataset.coinId = COIN_ID;
  el.textContent = '●';

  el.addEventListener('pointerdown', (e) => startDragCoinFromPool(e));
  coinPoolInner.appendChild(el);

  ui.coinEl = el;
  return el;
}

function getOwncoinHitUserId(clientX, clientY){
  for (const [uid, own] of ui.owncoinByUserId){
    const r = own.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top  + r.height/2;
    const dx = clientX - cx;
    const dy = clientY - cy;
    const rad = r.width/2;
    if ((dx*dx + dy*dy) <= (rad*rad)) return uid;
  }
  return null;
}

function moveCoinGhost(x, y){
  const g = coinDrag?.ghost;
  if (!g) return;
  g.style.left = `${x}px`;
  g.style.top  = `${y}px`;
}

async function ensurePower7StateIfNeeded(ownerId, number){
  if (!state.roomCode) return;
  if (Number(number) !== 7) return;

  const base = `rooms/${state.roomCode}`;
  const round = Number(state.game?.round || 1);

  await runTransaction(ref(db, `${base}/game/power7`), (cur) => {
    if (cur && cur.round === round && cur.giverId === ownerId && !cur.used) return cur;
    if (cur && cur.round === round && cur.used) return cur;
    return { round, giverId: ownerId, used:false, targetId:null, createdAt: Date.now() };
  });
}

async function setPowerDisplayForOwner(ownerId){
  if (!state.roomCode || !ownerId) return;
  const numSnap = await get(ref(db, `rooms/${state.roomCode}/hands/${ownerId}/numberCard`));
  const number = numSnap.val();
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    powerDisplay: {
      ownerId,
      number: Number(number ?? null),
      shownAt: Date.now()
    }
  });

  await ensurePower7StateIfNeeded(ownerId, Number(number ?? null));

  applyPlayableAnimToMyHand();
}

function renderCoins(){
  if (!state.game.started){
    if (ui.coinEl){
      ui.coinEl.remove();
      ui.coinEl = null;
    }
    return;
  }

  const c = state.coins?.[COIN_ID] || null;

  if (c?.ownerId){
    if (ui.coinEl){
      ui.coinEl.remove();
      ui.coinEl = null;
    }
    return;
  }

  const el = ensurePoolCoinEl();
  const locked = !!(c?.lockBy && c.lockBy !== state.userId);
  el.classList.toggle('locked', locked);

  const xPct = (c && c.xPct != null) ? c.xPct : 0.5;
  const yPct = (c && c.yPct != null) ? c.yPct : 0.5;
  placeCoinByPct(el, xPct, yPct);
}

function renderOwnedCoinsBadges(){
  for (const [uid, node] of ui.nodeByUserId){
    const owned = node.querySelector('.owned-coins');
    if (owned) owned.innerHTML = '';
  }
  ui.ownedCoinDotByOwnerId.clear();

  for (const coinId of Object.keys(state.coins || {})){
    const c = state.coins[coinId];
    if (!c || !c.ownerId) continue;

    const node = ui.nodeByUserId.get(c.ownerId);
    if (!node) continue;
    const owned = node.querySelector('.owned-coins');
    if (!owned) continue;

    const dot = document.createElement('div');
    dot.className = 'owned-coin-dot';
    dot.textContent = '●';
    dot.dataset.coinId = coinId;
    dot.dataset.ownerId = c.ownerId;

    const locked = !!(c.lockBy && c.lockBy !== state.userId);
    dot.classList.toggle('locked', locked);

    dot.addEventListener('pointerdown', (e) => startDragCoinFromOwned(e, coinId, c.ownerId));

    owned.appendChild(dot);
    ui.ownedCoinDotByOwnerId.set(c.ownerId, dot);
  }
}

function startDragCoinFromPool(e){
  if (!state.roomCode) return;
  if (!state.game.started) return;

  const c = state.coins?.[COIN_ID];
  if (c?.ownerId) return;
  if (c?.lockBy && c.lockBy !== state.userId) return;

  e.preventDefault();

  const realEl = ensurePoolCoinEl();
  const pointerId = e.pointerId;
  realEl.setPointerCapture?.(pointerId);

  const ghost = realEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  document.body.appendChild(ghost);

  realEl.style.opacity = '0.25';

  coinDrag = { pointerId, ghost, source:'pool', sourceOwnerId:null, raf:null, lastClientX:e.clientX, lastClientY:e.clientY };

  const { xPct, yPct } = pctFromClientXY(e.clientX, e.clientY);
  update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
    xPct, yPct,
    lockBy: state.userId,
    updatedAt: Date.now()
  });

  moveCoinGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    coinDrag.lastClientX = ev.clientX;
    coinDrag.lastClientY = ev.clientY;

    moveCoinGhost(ev.clientX, ev.clientY);

    const poolRect = coinPoolInner.getBoundingClientRect();
    const inPool = rectContainsPoint(poolRect, ev.clientX, ev.clientY);
    if (!inPool) return;

    if (coinDrag.raf) return;
    coinDrag.raf = requestAnimationFrame(() => {
      coinDrag.raf = null;
      const { xPct, yPct } = pctFromClientXY(coinDrag.lastClientX, coinDrag.lastClientY);
      update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        xPct, yPct,
        lockBy: state.userId,
        updatedAt: Date.now()
      });
    });
  };

  const onUp = async (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    coinDrag.ghost.remove();
    coinDrag = null;
    realEl.style.opacity = '';

    const poolRect = coinPoolInner.getBoundingClientRect();
    const inPool = rectContainsPoint(poolRect, ev.clientX, ev.clientY);

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);

    if (hitUid){
      await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        ownerId: hitUid,
        lockBy: null,
        updatedAt: Date.now()
      });
      await setPowerDisplayForOwner(hitUid);
      return;
    }

    if (inPool){
      const { xPct, yPct } = pctFromClientXY(ev.clientX, ev.clientY);
      await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
        xPct, yPct,
        lockBy: null,
        updatedAt: Date.now()
      });
      return;
    }

    await update(ref(db, `rooms/${state.roomCode}/coins/${COIN_ID}`), {
      lockBy: null,
      updatedAt: Date.now()
    });
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

function startDragCoinFromOwned(e, coinId, currentOwnerId){
  if (!state.roomCode) return;
  if (!state.game.started) return;

  const c = state.coins?.[coinId];
  if (!c) return;
  if (c.lockBy && c.lockBy !== state.userId) return;

  e.preventDefault();

  const srcEl = e.currentTarget;
  if (!(srcEl instanceof HTMLElement)) return;

  const pointerId = e.pointerId;
  srcEl.setPointerCapture?.(pointerId);

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  document.body.appendChild(ghost);

  srcEl.style.opacity = '0.25';

  coinDrag = { pointerId, ghost, source:'owned', sourceOwnerId:currentOwnerId, raf:null, lastClientX:e.clientX, lastClientY:e.clientY };

  update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
    lockBy: state.userId,
    updatedAt: Date.now()
  });

  moveCoinGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    coinDrag.lastClientX = ev.clientX;
    coinDrag.lastClientY = ev.clientY;
    moveCoinGhost(ev.clientX, ev.clientY);
  };

  const onUp = async (ev) => {
    if (!coinDrag || ev.pointerId !== coinDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    coinDrag.ghost.remove();
    coinDrag = null;
    srcEl.style.opacity = '';

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);

    if (hitUid){
      await update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
        ownerId: hitUid,
        lockBy: null,
        updatedAt: Date.now()
      });
      await setPowerDisplayForOwner(hitUid);
      return;
    }

    await update(ref(db, `rooms/${state.roomCode}/coins/${coinId}`), {
      ownerId: null,
      lockBy: null,
      updatedAt: Date.now()
    });
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

/* =========================
   ★効果7：霊魂カードUI（コインownが7のプレイヤーだけ）
   ========================= */
function updatePower7UI(){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  const p7 = state.game?.power7 || null;

  const shouldShow =
    started &&
    phase === 'collect' &&
    !!pd &&
    Number(pd.number) === 7 &&
    pd.ownerId === state.userId &&
    !(p7 && p7.used);

  spiritOverlay.classList.toggle('hidden', !shouldShow);

  if (shouldShow){
    spiritCard.style.backgroundImage = `url('${ASSET.roleFront["霊魂"] || ''}')`;
    spiritCard.textContent = '';
  } else {
    spiritCard.textContent = '霊魂';
  }
}

let spiritDrag = null;

function moveSpiritGhost(x, y){
  const g = spiritDrag?.ghost;
  if (!g) return;
  g.style.left = `${x}px`;
  g.style.top  = `${y}px`;
}

function startDragSpirit(e){
  const started = !!state.game?.started;
  const phase = state.game?.phase || 'collect';
  const pd = state.game?.powerDisplay || null;
  const p7 = state.game?.power7 || null;

  if (!started) return;
  if (phase !== 'collect') return;
  if (!pd || Number(pd.number) !== 7) return;
  if (pd.ownerId !== state.userId) return;
  if (p7 && p7.used) return;

  e.preventDefault();
  const pointerId = e.pointerId;
  spiritCard.setPointerCapture?.(pointerId);

  const ghost = spiritCard.cloneNode(true);
  ghost.classList.add('drag-ghost');
  document.body.appendChild(ghost);

  spiritCard.style.opacity = '0.25';
  spiritDrag = { pointerId, ghost };

  moveSpiritGhost(e.clientX, e.clientY);

  const onMove = (ev) => {
    if (!spiritDrag || ev.pointerId !== spiritDrag.pointerId) return;
    moveSpiritGhost(ev.clientX, ev.clientY);
  };

  const onUp = (ev) => {
    if (!spiritDrag || ev.pointerId !== spiritDrag.pointerId) return;
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);

    spiritDrag.ghost.remove();
    spiritDrag = null;
    spiritCard.style.opacity = '';

    const hitUid = getOwncoinHitUserId(ev.clientX, ev.clientY);
    if (!hitUid) return;

    const targetName = (state.players || []).find(p => p.id === hitUid)?.name || '誰か';
    pendingGiveTargetId = hitUid;
    pendingGiveTargetName = targetName;
    giveMessage.textContent = `「${targetName}」に授けますか？`;
    giveDialog.classList.remove('hidden');
  };

  window.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
}

spiritCard.addEventListener('pointerdown', startDragSpirit);

/* =========================
   ホスト設定UI
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await startGameDeal();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/plays`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/coins`)),
    remove(ref(db, `${base}/discard`)),
  ]);

  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
});

/* =========================
   リサイズ時に位置を更新
   ========================= */
window.addEventListener('resize', () => {
  renderPlays();
  renderCoins();
  renderOwnedCoinsBadges();
  renderDiscardTable();
  renderTableCards();
  updatePowerBanner();
  updatePower7UI();
  applyPlayableAnimToMyHand();
});
</script>
</body>
</html>
